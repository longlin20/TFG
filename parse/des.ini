%%%%%%%%%%%%%%%%
% WARNING
%
%
% DO NOT EDIT THIS FILE
% 
% Edit des_common.ini instead
%%%%%%%%%%%%%%%%
/start_stopwatch
% Start logging
/output only_to_log
/log debug.txt
/compact_listings on
/running_info batch
/keep_answer_table off
/datalog
% Reset databases
/open_db access
/drop_all_relations
/drop_all_relations
/close_db access
/open_db db2
/drop_all_relations
/drop_all_relations
/close_db db2
/open_db mysql
/drop_all_relations
/drop_all_relations
/close_db mysql
% /open_db oracle
% /drop_all_relations
% /drop_all_relations
% /close_db oracle
/open_db postgresql
/drop_all_relations
/drop_all_relations
/close_db postgresql
/open_db sqlserver
/drop_all_relations
/drop_all_relations
/close_db sqlserver
/set_flag debug_mode basic
%
% SAFE OFF
%
% Disable program simplification
/simplification off
% Disable program transformation
/safe off
% Next should be ok
X is 1
% Next raises run-time exception, execution avoided
X is Y
% Next raises run-time exception, execution avoided
p(X) :- X is Y
% Next raises run-time exception, execution avoided
p(X) :- Y is X
% Next should be ok
p(X) :- X is 1
% Next should be ok
X is 1,X > 0
% Next raises run-time exception, execution avoided
X > 0,X is 1
% Next is unsafe and not computed
not(p(X))
% Next is unsafe and not computed
p(X):-not(p(X))
% Next is unsafe but asserted
/assert p(X)
% Next is unsafe and raises run-time exception, but asserted
/assert p(X) :- Y>X
% Next is unsafe and raises run-time exception, but asserted
/assert p(X) :- Y>X,q(Y)
% Next is unsafe and raises run-time exception
/assert p(X) :- Y>X,Y=1
%
% SAFE ON
%
% Abolish database
/abolish
% Enable program transformation
/safe on
% Next should be ok
X is 1
% Next raises run-time exception, execution avoided
X is Y
% Next raises run-time exception, execution avoided
p(X) :- X is Y
% Next raises run-time exception, execution avoided
p(X) :- Y is X
% Next should be ok
p(X) :- X is 1
% Next should be ok
X is 1, X > 0
% Next would raise run-time exception, transformed and execution allowed
X > 0,X is 1
% Next is unsafe and not computed
not(p(X))
% Next is unsafe and not computed
p(X):-not(p(X))
% Next is unsafe but asserted
/assert p(X)
% Next is unsafe and raises run-time exception, but asserted
/assert p(X) :- Y>X
% Next is unsafe, transformed by safety, may raise run-time exception, but asserted
/assert p(X) :- Y>X,q(Y)
% Next is unsafe, transformed by safety, may raise run-time exception, but asserted
/assert p(X) :- Y>X,Y=1
% Next is unsafe, may raise run-time exception, but asserted
/assert p(X) :- X>1
% Next is safe, transformed and asserted
/assert p(X) :- not(q(X)),X is 1
% Next is safe, transformed and asserted
/assert p(X) :- not(q(X)),X>Y,r(Y),X is 1
% Next goal raises an exception
p(X)
/retractall p(X)
% Enable program simplification
/simplification on
% Next is unsafe, transformed by simplification, and may raise run-time exception
/assert p(X) :- Y>X,Y=1
%
% SIMPLIFICATION vs. SAFETY
%
/simplification off
/safe off
X=Y
/simplification on
/safe off
X=Y
/simplification off
/safe on
X=Y
/simplification on
/safe on
X=Y
/simplification off
/safe off
 X<Y,X=Y,X=1,Y=2
/simplification on
/safe off
X<Y,X=Y,X=1,Y=2
/simplification off
/safe on
X<Y,X=Y,X=1,Y=2
/simplification on
/safe on
X<Y,X=Y,X=1,Y=2
/simplification off
/safe off
X=1;Y=2
/simplification on
/safe off
X=1;Y=2
/simplification off
/safe on
X=1;Y=2
/simplification on
/safe on
X=1;Y=2
/simplification off
/safe off
(X=1;X=2),Y=3
/simplification on
/safe off
(X=1;X=2),Y=3
/simplification off
/safe on
(X=1;X=2),Y=3
/simplification on
/safe on
(X=1;X=2),Y=3
%
% SINGLETONS
%
/undef_pred_warnings off
p:-q(X)
p:-q(X);r(X)
q(X);r(X)
/assert p:-q(X);r(X)
/retract p:-q(X);r(X)
/undef_pred_warnings on
%
% ARITHMETICS
%
/status
X is 1
X is 1, Y is X+1
% Next yields error
X is 1E1
X is 1.1E1
X is 1.1E+1
X is 1.1E-1
% Next yields error
X is 1.E1
X is 1.0E1.
X is ln(e)
X is ln(cos(0))+1
X is pi*sqrt(2)
X is e-e+e
X is +1
X is +-1
X is -+1
X is --1
X is ---1
%
% NULLS
%
/development on
X is null
X=null
X=null,Y=null,X=Y
X=null,Y=null,X\=Y
/development off
X is null
X=null
X=null,Y=null,X=Y
X=null,Y=null,X\=Y
/duplicates off
/abolish n/2
/assert n(1,null)
/assert n(1,null)
:-type(n(a:int,b:int))
n(X,Y)
distinct(n(X,Y))
distinct([Y],n(_X,Y))
count(n(_X,_Y),C)
count_distinct(n(_X,_Y),C)
count(n(_X,Y),Y,C)
count_distinct(n(_X,Y),Y,C)
count(n(X,_Y),X,C)
count_distinct(n(X,_Y),X,C)
/duplicates on
n(X,Y)
distinct(n(X,Y))
distinct([Y],n(_X,Y))
count(n(_X,_Y),C)
count_distinct(n(_X,_Y),C)
count(n(_X,Y),Y,C)
count_distinct(n(_X,Y),Y,C)
count(n(X,_Y),X,C)
count_distinct(n(X,_Y),X,C)
/duplicates off
%
% OUTER JOIN DATALOG OPERATORS
%
/assert t(1)
/assert t(2)
/assert t(null)
/assert s(1)
lj(t(X),s(Y),X=Y)
lj(t(X),s(X),true)
lj(t(X),s(Y),(X=Y;X>Y))
lj(t(X),s(Y),X=Y),X>=Y
lj(t(X),rj(s(Y),t(Z),Y=Z),X=Y)
/assert v(X):-lj(s(X),t(Y),X=Y)
%
% DISJUNCTIVE QUERIES AND BODIES
%
X=1;X=2
X=1;X is 2
% The following raises an exception (is)
X is null ; X=null
X=null ; X=1
%
% PROGRAM SIMPLIFICATIONS
%
/abolish
/simplification off
p(X) :- true,X=1.
/simplification on
p(X) :- true,X=1.
%
% RESTRICTED PREDICATES
%
/abolish
/duplicates off
/assert p
/assert q:- -p=>p
q
p
-p
not(p)
not(q)
-q
/abolish
/assert p
p
not(p)
/assert -p
p
not(p)
-p
/assert p(1)
/assert p(2)
/assert -p(1)
p(X)
p(1)/\-p(1)/\p(2)=>p(X)
/duplicates on
p(1)/\-p(1)/\p(2)=>p(X)
/duplicates off
/abolish
/assert -p :- -p
-p
p
not(p)
/abolish
/assert p(X):-X=1;p(Y),Y<10,X=Y+1
/assert -p(X):-p(X),X mod 2=0
p(X)
/assert -p(X) :- p(X)
p(X)
/retract -p(X) :- p(X)
/assert -p(X) :- -p(X)
p(X)
%
% NON-CACHEABLE
%
/abolish
% Non-cacheable built-ins: solve once for each solving path
/assert n(X,R) :- X=0,'$rand'(R) ; n(Y,_),Y<10,X=Y+1,'$rand'(R).
:-type(n(a:int,b:float))
create table t as select * from n
create table s as select * from n
% select iif(count(*)>0,'ok','error') from select * from t minus select * from s
select 'ok' from (select * from t minus select * from s) having count(*)>0
_X=rand, _Y=rand, _X \= _Y
% Mix with recursion and TOP-N
with rnd(c) as (select rand union all select rand from rnd), rnd10(c) as (select top 10 c from rnd) select count(*) from rnd10;
/duplicates
/abolish
/duplicates on
/assert rnd(B) :- '$rand'(C),D=C*36,E=integer(D),F=1+E,'$substr'(abcdfghijklmnopqrstuvwxyz01234567890,F,1,B)
/assert rnd(G) :- rnd(_H),'$rand'(I),J=I*36,K=integer(J),L=1+K,'$substr'(abcdfghijklmnopqrstuvwxyz01234567890,L,1,G)
_=rand(1),top(1,rnd(X)).
_=rand(1),top(2,rnd(X)).
_=rand(1),top(3,rnd(X)).
_=rand(1),top(4,rnd(X)).
_=rand(1),top(10,rnd(X)).
_=rand(1),top(2,rnd(X)),top(2,rnd(Y)).
_=rand(1),top(2,rnd(X)),top(3,rnd(Y)).
_=rand(1),top(3,rnd(X)),top(2,rnd(Y)).
_=rand(1),top(3,rnd(X)),top(3,rnd(Y)).
/duplicates off
_=rand(1),top(1,rnd(X)).
_=rand(1),top(2,rnd(X)).
_=rand(1),top(3,rnd(X)).
_=rand(1),top(4,rnd(X)).
_=rand(1),top(10,rnd(X)).
_=rand(1),top(2,rnd(X)),top(2,rnd(Y)).
_=rand(1),top(2,rnd(X)),top(3,rnd(Y)).
_=rand(1),top(3,rnd(X)),top(2,rnd(Y)).
_=rand(1),top(3,rnd(X)),top(3,rnd(Y)).
%
% TABLED AGGREGATION
%
% Built-in with (first) aggregate record: solve once for all solving paths
% (otherwise the seed is set several times)
/abolish
/assert n(X,R) :- X=0,'$rand'(1,R) ; n(Y,_),Y<10,X=Y+1,'$rand'(R).
:-type(n(a:int,b:float))
create table t as select * from n
create table s as select * from n
% select iif(count(*)=0,'ok','error') from select * from t minus select * from s
select 'ok' from (select * from t minus select * from s) having count(*)=0
_X=rand(1),_Y=rand,_Z=rand, _X \= _Y, _Y \= _Z
/abolish
/assert r(1,X):-'$rand'(1,X)
/assert r(N,X):-r(N1,_),N1<5,N=N1+1,'$rand'(X)
/assert r(N,X):-r(N1,_),N1=5,N=N1+1,'$rand'(1,X)
/assert r(N,X):-r(N1,_),N1>5,N1<10,N=N1+1,'$rand'(X)
count_distinct(r(X,Y),Y,C)
%
% SCOPING
%
/abolish
/show_compilations on
/compact_listings on
create table t(a int);
/assert t(1)
select 1;
project 1 (dual);
select 1 a;
rename v(a) (project 1 (dual));
select 1 a, a+1;
% No way in RA, another formulation:
project a,a+1 (rename v(a) (project 1 (dual)));
select a+2,1 a, a+1;
project a+2,a,a+1 (rename v(a) (project 1 (dual)));
select a+2,1+1 a, a+1;
project a+2,a,a+1 (rename v(a) (project 1+1 (dual)));
select a from t;
project a (t);
select t.a from t;
project t.a (t);
% Error:
select b from t;
% Error:
project b (t);
select t1.a from t t1;
project t1.a (rename t1(a) (t));
% Error:
select t1.a from t;
% Error:
project t1.a (t);
select a from t where a=1;
project a (select a=1 (t));
select a from t where t.a=1;
project a (select t.a=1 (t));
% Error:
select a from t where t1.a=1;
% Error:
project a (select t1.a=1 (t));
select a from t t1 where t1.a=1;
project a (select t1.a=1 (rename t1(a) (t)));
% Error:
select a from t t1 where t.a=1;
% Error:
project a (select t.a=1 (rename t1(a) (t)));
% Error:
select a from t where t.b=1;
% Error:
project a (select t.b=1 (t));
% Error:
select a b from t where b=1;
% Error:
rename v(b) (select b=1 (t));
% Error:
select a from t,t;
% Error:
project a (t product t);
% Should be an error:
project t.a (t product t)
select a from (select a from t);
select t1.a from (select a from t) t1;
% Error:
select t.a from (select a from t);
% Should not be an error in RA:
project t.a (project a (t));
select b from (select a b from t);
project b (rename v(b) (t));
% Error:
select a from (select a b from t);
% Error:
project a (rename v(b) (t));
% Error:
select t.a from (select a b from t);
% Error:
project t.a (rename v(b) (t));
% Error:
select t1.a from (select a b from t) t1;
% Error:
project t1.a (rename t1(b) (t));
select t1.b from (select a b from t) t1;
project t1.b (rename t1(b) (t));
create table s(b int);
/assert s(1)
select * from t natural inner join t;
t njoin t;
select * from t inner join s on a=b;
t zjoin a=b s;
select * from t inner join s on t.a=s.b;
t zjoin t.a=s.b s;
% Error: natural.c is not known. NATURAL and USING are not compatible. So, 'natural' is used here as a valid table renaming:
select * from t natural inner join t using (c);
select c from (select a c from t) v where v.c=1;
project c (select v.c=1 (rename v(c) (t)));
% Error:
select a from (select a c from t) v where v.c=1;
% Error:
project a (select v.c=1 (rename v(c) (t)));
% Error:
select c from (select a c from t) v where v.a=1;
% Error:
project c (select v.a=1 (rename v(c) (t)));
% Error:
select v.c from (select a c from t) v where v.a=1;
% Error:
project v.c (select v.a=1 (rename v(c) (t)));
% Error:
select t.* from (select * from t) t1;
select t.* from t;
select t1.* from t t1;
% Error:
select t1.* from t;
select t1.* from t t1, t;
select t1.*,t.* from t t1, t;
select t.* from t t1, t;
% Error:
select t2.* from t t1, t;
select * from (select a from t);
%
% SYNTAX ERRORS
%
% -- DQL
lj
lj(X)
lj(X,Y)
lj(X,Y,Z)
lj(p(X),Y,Z)
lj(p(X),q(Y),Z)
lj(X,Y,Z,U)
A
a,
p()
,a
p(-1.)
p(+1)
p(.1)
p(1.E23)
p(1E23)
A(a)
p(foo''s)
p(foo's)
p('foo's')
% -- DDL
drop t
drop table if exist t
drop table t if exist
drop view if exist v
drop view v if exist
/sql create
create t(a int)
/sql create t(a int)
create tabe t(a int)
create table t
create table t(a)
create table t(a intiger)
create table t(a integer) as
create or replace table t(a int not nul)
create or replace table t(a int primary kye) 
create or replace table t(a int candidate)
create or replace table t(a int determined from a)
create or replace table t(a int references)
create or replace table t(a int references s a)
create or replace table t(a int references s()a)
create or replace table t(a int foreign key s)
create or replace table t(a int defaul 0)
create or replace table t(a integer check (>0))
create or replace table t(a integer check >0)
create or replace table t(a int, b int, foreign key a,b references s)
create or replace table t(a int, b int, c int, d int, check (a,b) determined by c,d)
create or replace table t(a char())
create or replace table t(a number(1,))
create table like
create table t(a) like s
create table t like s(a)
create table t like s (a)
/sql alter t add constraint primary key(a)
alter table t add primary key(a) 
alter table t add constraint frimary key(a)
alter table t add constraint primary key(a), primary key(a)
/sql rename t to s
rename table t(a) to s
rename table t to (s)
rename table v as t
rename table t to s(a)
create or replace table t(a int primary key determined by b, b string default '', check (a>0))
/describe t
alter table t alter column a set data type varchar(10)
/describe t
alter table t drop column a 
/describe t
alter table t drop column b 
create or replace table t(a) as select 1
create view
/datalog create view
create view v select 1
create view v() as select 1
create view v(a)
create view v(a) as
drop database $des
n
drop database x
create database x
% DML
delete * from t
delete from
delete from t where >0
insert into t
insert into t (1,2)
insert into t values 1
insert into t()
insert into t(a) (1)
insert into t(a) values 1 
insert into t values (1,1,a)
update table t set a=1
update t a=1
update t set a=1 w
update t set a=1 where
update t set a=1 where a>0 true
% DQL
/sql with
with v(a) as select 1
with v(a) as select 1 from dual
with v(a) select 1 select * from v
/sql assume
assume select 1 in t(a)
/sql assume v(a) as select 1 select * from v
select 1 where 1<2
select from dual where count(*)>0
select * from t as t1 fetch
select * from t as t1 fetch first
select * from t as t1 fetch first 1 rows
select + from t
select *.t from t     
select \* from t
select * from t t1 where \a
select * from t where a>0 and <3
select * from t group by "1 
%
% DISPLAYED SCHEMAS
%
create or replace table s like t
select a from t
select a from t t1
select a b from t t1
select a b from t
select 1
select 1 a
select t.a,s.a from t,s
% Joins:
/abolish
create table t(a int);
create table s(a int);
create table u(a int);
select * from t natural inner join s;
t njoin s;
select * from t inner join s on t.a=s.a;
t zjoin t.a=s.a s;
select * from t t1 inner join s on t1.a=s.a;
% Error:
select * from t t1 inner join s on t.a=s.a;
% Error:
(rename t1(a) (t)) zjoin t.a=s.a s;
select * from t natural inner join (s natural inner join u);
t njoin s njoin u;
select * from t inner join (s inner join u on s.a=u.a) on t.a=s.a;
t zjoin t.a=s.a (s zjoin s.a=u.a u);
select * from t t1 natural inner join t t2;
(rename t1(a) (t)) njoin (rename t2(a) (t));
% Error
(rename t1(a,b) (t)) njoin (rename t2(a) (t));
/abolish
create table t(a int, b int);
create table s(b int, c int);
create table u(c int, d int);
select * from t natural inner join (s natural inner join u);
t njoin s njoin u;
select * from (select * from t) natural inner join (select * from s);
(select true (t)) njoin (select true (s));
select * from (select * from t) t1 inner join (select * from s) s1 on t1.b=s1.b;
(rename t1(a,b) (select true (t))) zjoin t1.b=s1.b (rename s1(b,c) (select true (s)));
% Error:
select * from (select * from t) t1 inner join (select * from s) s1 on t.b=s.b;
% Error:
(rename t1(a,b) (select true (t))) zjoin t.b=s.b (rename s1(b,c) (select true (s)));
select * from (select * from t) natural inner join (select * from s) natural inner join (select * from u);
select true ((select true (t)) njoin (select true (s)) njoin (select true (u)))
/show_compilations off
/abolish
%
% DATA TYPES AND FUNCTIONS
%
select case when 1=1 then 'a' else 'b' end
select case 1 when 1 then 'a' else 'b' end
select concat('a','b')
select 'a'||'b'
select 'a'+'b'
select length('a')+length('b')
select 'ok' from dual where 'asdf' like '%'
select 'ok' from dual where 'asdf' like 'as__'
select 'ok' from dual where 'as_df' like '%_%' escape '_'
select substr(lower('A')||upper('b'),1,2)
select cast('1' as float)
select cast(month(date '2017-02-01') as string)
select extract(hour from time '22:05:31')
X=cast(date(2017,8,31),datetime)-datetime(2017,8,30,23,59,59)
select current_date-current_date
select current_time-current_time
'$day'(date(2017,02,01),Day)
/date_format YYYY-MM-DD
select date '2017-02-01' - 1
select date '2017-02-01'-date '2016-02-01'
select datetime '2017-02-01 10:00:00'-1
select datetime '2017-02-01 10:00:00'-datetime '2017-02-01 10:00:01'
/assert t(date(2018,12,32))
/assert t(date(1582,11,-31))
/assert t(time(0,0,-1))
/listing
select date '1582-10-15'-1;
select date '1582-10-4'+1;
select time '0:0:0'-1;
select time '0:0:-1';
select datetime '1-1-1 0:0:0' - 1;
select cast((datetime '1-1-1 0:0:0' - 1) as string);
/date_format DD/MM/YYYY
select date '22/11/2020';
/date_format YYYY-MM-DD
%
% SQL SEMANTIC ERRORS
%
/cd debug
/p des_semantic.ini
/cd ..
%
% TESTS
%
/c examples2/paths
% Failed with optimize_edb
path(1,X).

% EXAMPLES
%
/consult examples/family.dl
/c examples/family
/[examples/family]
/cd examples
/[family,family]
/cd
/pwd
/cd examples
/ls
/dir
/ls examples
/dir examples
/ls ..
/dir ..
/ls .
/dir ..
/ls ...
/dir ...
/simplification
/simplification on
/simplification off
/safe
/safe on
/safe off
/development
/development on
/development off
/timing
/timing on
/timing off
/verbose
/verbose on
/verbose off
/pwd
/consult ../Debug/a
/listing
/assert a(a4)
/listing
a(a3)
a(a5)
a(X)
/prolog a(X)
;
;
;
;
% Next yields error
/assert a :- b,
% Next yields error
/assert a, :- b
% Next yields error
a(
% Next yields error
a,b,
/assert b(a1)
/assert b(a2)
/prolog a(X),b(X)
;

/verbose on
/builtins
a

/help
a

/[relop]
projection(X)
d(X) :- a(X), not(b(X))
a(X) :- b(X)
union(X)
left_join(X,Y)
right_join(X,Y)
full_join(X,Y)
/c paths
path(X,Y)
/[family]
ancestor(tom,X)
son(S,F,M) :- father(F,S),mother(M,S).
father(F,S),mother(M,S)
/[tranclosure]
pqs(X,Y)
/c trains
%/timing on
%/negation
%/negation strata
inconsistent(X,Y)
/clear_et
%/negation et_not
inconsistent(X,Y)
/c bom
all_subparts(Part,Sub)
basic_subparts(Prt,BasicP)
fastest(Part,Time)
timeForbasic(AssPart,BasicSub,Time)
howsoon(AssPart,Time)
%/negation strata
/c parity
br_is_even
not(br_is_even)
/cd ../debug
/c p
p
a
/pdg
/strata
/c q
p
q
not(a)
/pdg
/strata
% Next program for goal p does not terminate for et_not
%/negation strata
/c u
p
q
a
/pdg
/strata
/cd
/cd examples
/abolish
% Switch to SQL interpreter
/sql
select 1
select 1 from dual
%drop schema;
drop table a;
drop table b;
drop table c;
drop table d;
% Creating tables
create table a(a string);
create table b(b string);
create table c(a string,b string);
create table d(a int);
create or replace table e(a int, b float default pi/2, c string not null default null);
alter table a add  constraint primary key a;
alter table a add  constraint primary key (a);
alter table a drop constraint primary key a;
alter table a drop constraint primary key (a);
alter table b add  constraint not null b;
alter table b add  constraint unique(b);
alter table b drop constraint not null b;
alter table b drop constraint unique(b);
alter table c add  constraint candidate key b;
alter table c add  constraint check a determined by b;
alter table c add  constraint check (a,b) determined by (a,b);
alter table c drop constraint candidate key b;
alter table c drop constraint check a determined by b;
alter table c drop constraint check (a,b) determined by (a,b);
alter table d add  constraint check (a>0);
alter table d drop constraint check a>0;
% Next, error:
alter table d add constraint primary key k;
% Listing the database schema
/dbschema
% Inserting values into tables
insert into a values ('a1');
insert into a values ('a2');
insert into a values ('a3');
insert into b values ('b1');
insert into b values ('b2');
insert into b values ('a1');
insert into c values ('a1','b2');
insert into c values ('a1','a1');
insert into c values ('a2','b2');
% Next, error
insert into e(a) values(0);
insert into e(a,c) values(0,'');
insert into e(a,b,c) values(default,default,'');
insert into e default values;
drop table e;
% Testing the just inserted values
select * from a;
select * from b;
select * from c;
% Projection
select a from c;
% Selection
select a from a where a='a2';
% Cartesian product
select * from a,b;
% Join
select a from a inner join b on a.a=b.b;
% Union 
select * from a union select * from b;
% Difference
select * from a except select * from b;
% Inserting tuples
insert into c select a.a,b.b from a,b where a.a=b.b or b.b='a1';
% Deleting tuples
delete from c where b='a1';
delete from c;
delete from b where b in (select * from a);
delete from a where not exists (select * from c where c.a=a.a);
% Examples
create table edge(origin string,destination string);
insert into edge values('a','b');
insert into edge values('a','c');
insert into edge values('b','a');
insert into edge values('b','d');
create view paths(origin,destination) as with recursive path(origin,destination) as (select * from edge) union (select path.origin,edge.destination from path,edge where path.destination=edge.origin) select * from path;
select * from paths;
create table father(father string,child string);
insert into father values('tom','amy');
insert into father values('jack','fred');
insert into father values('tony','carolII');
insert into father values('fred','carolIII');
create table mother(mother string,child string);
insert into mother values('graceI','amy');
insert into mother values('amy','fred');
insert into mother values('carolI','carolII');
insert into mother values('carolII','carolIII');
create view parent(parent,child) as select * from father union select * from mother;
create or replace view ancestor(ancestor,descendant) as select parent,child from parent union select parent,descendant from parent,ancestor where parent.child=ancestor.ancestor;  
select * from ancestor where ancestor='tom';
select father.child,father,mother from father,mother where father.child=mother.child;
create table p(x string,y string);
insert into p values ('a','b');
insert into p values ('c','d');
create table q(x string,y string);
insert into q values ('b','c');
insert into q values ('d','e');
create view pqs(x,y) as select * from p union select * from q union select pqs.x,p.y from pqs,p where pqs.y=p.x union select pqs.x,q.y from pqs,q where pqs.y=q.x;
create or replace table s([a] int, [b] string, [c] char)
create or replace table t([a] int, [b] string, [c] char)
% Next, warning (no tuple met)
INSERT INTO [t](c,a) select a,c from s
% Next, error (number of arguments)
INSERT INTO [t] select a,c from s
% Next, error (number of arguments)
INSERT INTO [t](a,b) select a,b,c from s
% Next, error (number of arguments)
INSERT INTO [t](a,b,c) select a,c,b,c from s
INSERT INTO [s] VALUES(1,'Una cadena',NULL) 
% Next, type mismatch
INSERT INTO [t](c,a) select a,c from s  
% Next, type mismatch
INSERT INTO [t](c,a,b) select a,b,c from s
% Next, type mismatch
INSERT INTO [t](a,b,c) select a,c,b from s
INSERT INTO [t](a,b,c) select a,b,c from s
INSERT INTO [t](a,b,c) select * from s
INSERT INTO [t](a) select a from s 
INSERT INTO [t](a) select 2
% Next, type mismatch
INSERT INTO [t](b) select a from s
INSERT INTO [t](b) select b from s
INSERT INTO [t](b) select c from s
INSERT INTO [t](c) select c from s
% Next, type mismatch
INSERT INTO [t](c) select b from s
% Next, type mismatch
INSERT INTO [t](c) select a from s
drop database;
y
% Sample SQL queries
% Creating (untyped) relations
create table t(a int,b int);
create table s(a int,b int);
create table r(a int,b int);
% Examining the database schema
/dbschema
% Inserting values as data tuples
insert into t values(1,1);
insert into s values(1,2);
insert into s values(2,1);
insert into r values(1,1);
% Inserting values from a query
insert into s select * from t;
% Selecting values from a table
select * from t;
select * from s;
select * from s where a=1;
select * from s where a=2 or b=2;
select * from s where not (a=2 or b=2);
select * from s where a<>1;
% Multitable queries
select * from t,s where t.a=s.a and t.b=s.b;
select * from t inner join s on t.a=s.a and t.b=s.b;
select * from t natural inner join s;
select * from t inner join s using (a,b);
select * from t inner join s using (a);
select * from t inner join s using (b);
% Set queries
(select * from s) union     (select * from t);
(select * from s) intersect (select * from t);
(select * from s) except    (select * from t);
% With statements
with p(a) as select a from t select a from p;
% Subqueries
select * from (select * from t) as r1, (select * from s) as r2 where r1.a=r2.b;
select * from (select a from t)
select a from (select a from t)
select a from (select * from t)
% Subqueries with In conditions
select * from s where s.a in select a from t;
select * from s where s.a not in select a from t;
select a from s where b not in ((select a from t where t.a=s.a) union (select a from t where b=1))
% Subqueries with ALL modifier
select a from t where a>=all (select min(a) from s);
select a from t t1 where not exists (select 1 from t t2 where t1.a=t2.a and exists (select 1 from s having t2.a < min(a)));
select t.a from t join r on t.a=r.a where t.a>=all (select min(a) from s);
select a from t natural join r where b>=all (select min(a) from s);
select a,b from t where b >= all (select min(b) from s group by a);
select a,b from t where b >= all (select min(b) from s where b>=all (select min(a) from r) group by a);
select 1 from t having count(*) <= all (select a from s);
select a from t group by a having count(*) <= all (select a from s);
select t.a from t join r on t.a=r.a group by t.a having count(*) <= all (select a from s);
select t.a from t join r on t.a=r.a group by t.a having count(*) <= any (select a from s);
% Subqueries with Exists conditions (correlated query)
select * from s where exists select a from t where t.a=s.a;
% FROM-less queries
select 1
select (select 1)
select (select (select 1))
% SQL statements in projection list
select (select a from t)
select (select a from t)+1
/assert t(2,2)
select (select a from t)+1
% Top-N queries
/show_compilations on
select distinct top 1 * from t
select top 1 distinct * from t
select distinct * from t fetch first 1 rows only
select top 1 distinct * from t fetch first 1 rows only
%  Next, error
select top 1 distinct * from t fetch first 10 rows only
% Offset
create view n(n) as select 0 union all select n+1 from n
select n from n offset 10 limit 10
drop view n
create view r(a) as select 1 union select a+1 from r
insert into t values(2,2),(3,3)
select * from (select top 1 a from r) t1, (select top 2 a from t) t2 where t1.a=t2.a
select * from (select top 2 a from r) t1, (select top 1 a from t) t2 where t1.a=t2.a
select * from (select top 1 a from t) t1, (select top 2 a from r) t2 where t1.a=t2.a
select * from (select top 2 a from t) t1, (select top 1 a from r) t2 where t1.a=t2.a
select * from (select top 1 a from t) t1, (select top 2 a from t) t2 where t1.a=t2.a
select * from (select top 2 a from t) t1, (select top 1 a from t) t2 where t1.a=t2.a
/show_compilations off
with p(a) as select 1 union select a+1 from p select top 10 a from p;
/duplicates on
with p(a) as select 1 union select a+1 from p select top 10 a from p;
with p(a) as select 1 union select a+1 from p select top 10 distinct a from p;
create table t1(a int);
insert into t1 with n(a) as select 1 union all select a+1 from n select top 10 * from n;
drop table t1;
% Creating views
create view ts(a,b) as select t.* from t,s where t.a=s.a and t.b=s.b;
select * from ts;
create view v3(a) as with p(a) as select a from t select a from p;
/dbschema
drop view v3;
create or replace view v(a) as select a from t where a in (select a from s where s.a=t.a) and exists (select b from r where r.b=t.a);
/dbschema
create or replace view v(a) as select a from t where a in (select a from s where s.a=t.a) and not exists (select b from r where r.b=t.a);
/dbschema
create or replace view v(a) as select a from t where a in (select a from s where s.a=t.a) and not exists (select b from r where r.b=t.a and r.a=t.b);
/dbschema
create or replace view v(a) as select a from t where a not in (select a from s where s.a=t.a) and not exists (select b from r where r.b=t.a and r.a=t.b);
/dbschema
create or replace view v(a) as select a from t where a in ((select a from s where s.a=t.a) union (select b from r where r.a<t.a))
/dbschema
create or replace view v(a) as select a from t where a not in ((select a from s where s.a=t.a) union (select b from r where r.a<t.a))
/dbschema
% Recursive views [GUW02]
create table flights(airline string,frm string,to string,departs int,arrives int);
insert into flights values ('UA','SF','DEN',930,1230);
insert into flights values ('AA','SF','DAL',900,1430);
insert into flights values ('UA','DEN','CHI',1500,1800);
insert into flights values ('UA','DEN','DAL',1400,1700);
insert into flights values ('AA','DAL','CHI',1530,1730);
insert into flights values ('AA','DAL','NY',1500,1930);
insert into flights values ('AA','CHI','NY',1900,2200);
insert into flights values ('UA','CHI','NY',1830,2130);
select * from flights;
% P.493 [GUW02]
WITH RECURSIVE Reaches(frm,to) AS (SELECT frm,to FROM flights) UNION (SELECT R1.frm,R2.to FROM Reaches AS R1, Reaches AS R2 WHERE R1.to=R2.frm) SELECT * FROM Reaches;
% P.495 [GUW02]
WITH Triples(airline,frm,to) AS SELECT airline,frm,to FROM flights, RECURSIVE Reaches(airline,frm,to) AS (SELECT * FROM Triples) UNION (SELECT Triples.airline,Triples.frm,Reaches.to FROM Triples,Reaches WHERE Triples.to = Reaches.frm AND Triples.airline=Reaches.airline) (SELECT frm,to FROM Reaches WHERE airline = 'UA') EXCEPT (SELECT frm,to FROM Reaches WHERE airline = 'AA');
%WITH 
%  Triples(airline,frm,to) AS 
%    SELECT airline,frm,to 
%    FROM flights,
%  RECURSIVE Reaches(airline,frm,to) AS 
%    (SELECT * FROM Triples) 
%    UNION 
%    (SELECT Triples.airline,Triples.frm,Reaches.to
%     FROM Triples,Reaches
%     WHERE Triples.to = Reaches.frm AND Triples.airline=Reaches.airline) 
%(SELECT frm,to FROM Reaches WHERE airline = 'UA') 
% EXCEPT 
%(SELECT frm,to FROM Reaches WHERE airline = 'AA');
WITH Triples(airline,frm,to) AS SELECT airline,frm,to FROM flights, RECURSIVE Reaches(airline,frm,to) AS (SELECT * FROM Triples) UNION (SELECT Triples.airline,Triples.frm,Reaches.to FROM Triples,Reaches WHERE Triples.to = Reaches.frm AND Triples.airline=Reaches.airline) (SELECT frm,to FROM Reaches WHERE airline = 'UA') EXCEPT (SELECT frm,to FROM Reaches WHERE airline = 'AA');
create view reach(frm,to) as WITH Triples(airline,frm,to) AS SELECT airline,frm,to FROM flights, RECURSIVE Reaches(airline,frm,to) AS (SELECT * FROM Triples) UNION (SELECT Triples.airline,Triples.frm,Reaches.to FROM Triples,Reaches WHERE Triples.to = Reaches.frm AND Triples.airline=Reaches.airline) (SELECT frm,to FROM Reaches WHERE airline = 'UA') EXCEPT (SELECT frm,to FROM Reaches WHERE airline = 'AA');
/multiline on
/abolish
WITH 
  even(x) AS
  SELECT 0
  UNION ALL
  SELECT odd.x+1
  FROM odd
  WHERE x < 10
  ,
  odd(x) AS
  SELECT even.x+1
  FROM even
  WHERE x < 10
--  SELECT x FROM even
  SELECT x FROM odd
 ;
% Next is non-stratifiable
create table r(a int);
with recursive p(x) as select * from r
except select * from q,
recursive q(x) as select * from r 
except select * from p
select * from p;
/multiline off
%
% AGGREGATES
%
/datalog
/abolish
% Aggregate predicates:
/assert p(1,2)
/assert p(2,2)
/assert q(1)
group_by((p(X,Y),q(Z)),[Y],R=count(Z))
count((p(X,Y),q(Z),X>=Z),C)
r(Y,C):-count((p(X,Y),q(Z),X>=Z),C)
/abolish
/assert t(1,2)
/assert t(1,2)
/assert t(3,4)
/assert t(null,null)
/assert t(null,null)
/duplicates on
count(t(_X,_Y),C)
count_distinct(t(_X,_Y),C)
sum(t(X,_Y),X,C)
sum_distinct(t(X,_Y),X,C)
avg(t(X,_Y),X,C)
avg_distinct(t(X,_Y),X,C)
times(t(_X,Y),Y,C)
times_distinct(t(_X,Y),Y,C)
min(t(X,_Y),X,C)
max(t(X,_Y),X,C)
sum(t(X,Y),X*Y,S)
/duplicates off
count(t(_X,_Y),C)
count_distinct(t(_X,_Y),C)
sum(t(X,_Y),X,C)
sum_distinct(t(X,_Y),X,C)
avg(t(X,_Y),X,C)
avg_distinct(t(X,_Y),X,C)
times(t(_X,Y),Y,C)
times_distinct(t(_X,Y),Y,C)
min(t(X,_Y),X,C)
max(t(X,_Y),X,C)
sum(t(X,Y),X*Y,S)
% Aggregate functions:
/duplicates on
group_by(t(_X,_Y),[],C=count)
group_by(t(_X,_Y),[],C=count_distinct)
group_by(t(X,_Y),[],C=sum(X))
group_by(t(X,_Y),[],C=sum_distinct(X))
group_by(t(X,_Y),[],C=avg(X))
group_by(t(X,_Y),[],C=avg_distinct(X))
group_by(t(_X,Y),[],C=times(Y))
group_by(t(_X,Y),[],C=times_distinct(Y))
group_by(t(X,_Y),[],C=min(X))
group_by(t(X,_Y),[],C=max(X))
group_by(t(X,Y),[],S=sum(X*Y))
/duplicates off
group_by(t(_X,_Y),[],C=count)
group_by(t(_X,_Y),[],C=count_distinct)
group_by(t(X,_Y),[],C=sum(X))
group_by(t(X,_Y),[],C=sum_distinct(X))
group_by(t(X,_Y),[],C=avg(X))
group_by(t(X,_Y),[],C=avg_distinct(X))
group_by(t(_X,Y),[],C=times(Y))
group_by(t(_X,Y),[],C=times_distinct(Y))
group_by(t(X,_Y),[],C=min(X))
group_by(t(X,_Y),[],C=max(X))
group_by(t(X,Y),[],S=sum(X*Y))
% Consult .dl file
/c aggregates.dl
/duplicates on
total_employees(T)
active_employees(T)
total_departments(D)
sum_salary(Sum)
avg_salary(AS)
min_salary(M)
max_salary(M)
emp_sal_gt_avg(C)
total_employees(D,T)
active_employees(D,T)
sum_salary(D,Sum)
avg_salary(D,AS)
min_salary(D,M)
max_salary(D,M)
emp_sal_gt_avg(D,C)
group_by(employee(_N,D,_S),[D],R=count)  
group_by(employee(_N,D,S),[D],R=count(S))
group_by(employee(_N,D,S),[D],count(S)>1)
group_by(employee(_N,D,S),[D],(R=count(S),R>1))
group_by((employee(_N,D,S),S>1000),[D],R=count(S))
group_by(employee(_N,D,S),[D],R=count(S)), S>1000
count(employee(_N,_D,S),S,T)
c(D,C):-count(employee(_N,D,S),S,C)
count((employee(_N,_D,S),avg(employee(_N1,_D1,S1),S1,A),S>A),C)
count((employee(_N,D,S),avg(employee(_N1,D,S1),S1,A),S>A),C)
avg(employee(N1,D,S1),S1,A),count((employee(N,D,S),S>A),C)
count_distinct(employee(N,D,S),D,C)
sum_distinct(employee(_N,_D,S),S,A)
avg_distinct(employee(_N,_D,S),S,A)
times_distinct(employee(_N,_D,S),S,A)
/duplicates off
/sql
drop database
y
/abolish
% Process .sql file
%/p aggregates.sql
create or replace table employee(name string, department string, salary int);
select count(*) from employee;
select count(salary) from employee;
insert into employee values('anderson','accounting',1200);
insert into employee values('andrews','accounting',1200);
insert into employee values('arlingon','accounting',1000);
insert into employee values('nolan',null,null);
insert into employee values('norton',null,null);
insert into employee values('randall','resources',800);
insert into employee values('sanders','sales',null);
insert into employee values('silver','sales',1000);
insert into employee values('smith','sales',1000);
insert into employee values('steel','sales',1020);
insert into employee values('sullivan','sales',null);
select * from employee;
select count(*),count(salary),min(salary),max(salary),sum(salary),avg(salary),times(salary) from employee;
select * from employee where name = (select min(name) from employee);
select min(name),max(name),avg(salary) from employee;
select department,count(salary),sum(salary),avg(salary),min(salary),max(salary) from employee group by department;
create or replace table parking(name string, lot string);
insert into parking values('anderson','a-1');
insert into parking values('randall','r-1');
insert into parking values('silver','s-1');
create or replace view v(a,b) as select department,max(salary) from employee group by department;
select * from v;
select * from employee natural inner join parking;
select department,max(lot) from employee natural inner join parking group by department;
% Incorrect aggregate statements:
select * from employee group by department;
create or replace view v as select * from employee group by department;
/ra group_by department name,count(*) true (employee);
/datalog g(N,C):-group_by(department(N,D,_S),[D],C=count).
drop database
y
% Switch to Datalog
/datalog
/simplification off
/verbose on
/development on
/assert p(1)
/assert p(2)
/assert p(X)
/assert p(X):-X=1;X=2
/simplification on
/assert p(X):-X=1;X=2
/development off
/listing
/listing p
/listing p/1
/listing p(1)
/listing p(X)
/listing p(X):-X=1;X=2
/development on
/listing
/listing p
/listing p/1
/listing p(1)
/listing p(X)
/listing p(X):-X=1;X=2
/retract p(X)
/retract p(X)
/retract p(X)
/retract p(X)
/listing
/assert p(1)
/assert p(2)
/assert p(X)
/retractall p(X)
/listing
/assert p(X):-X=1;X=2
/simplification off
/assert p(X):-X=1;X=2
/assert p(X):-X=1;X=2
/listing
/retract p(X):-X=1;X=2
/retract p(X):-X=1;X=2
/retract p(X):-X=1;X=2
/retract p(X):-X=1;X=2
/listing
/assert p(X):-X=1
/assert p(X):-X=1,X=2
/assert p(X):-X=1,X=2,X=3
/assert p(X):-X=1;X=2
/assert p(X):-X=1;X=2;X=3
/assert p(X):-X=1,X=2;X=3,X=4.
/pretty_print off
/listing
/pretty_print on
/listing
%/sql
create or replace table t(a int, b int)
select * from t
select count(*) from t
select count(*) from t group by a
insert into t values(1,1)
insert into t values(2,2)
select * from t
select count(*) from t
select count(*) from t group by a
select a,count(*) from t group by a
drop database
y
%
% TEST CASES
%
%/sql
drop database
y
/abolish
create or replace table t(a int primary key, b int)
create or replace view v(a,b) as select * from t where a=1
/test_case v
/test_case v all display
/test_case v display all
/test_case v positive display
/test_case v negative display
/test_case v all add
select * from t
/test_case v all replace
% Next should reject additions because of the primary key constraint on t
/test_case v all add
% Next view is not defined. Informative error
/test_case u
% Test cases for strings
create or replace table t(a string primary key)
create or replace view v(a) as select a from t where a=''
% No way to handle empty strings
/test_case v
create or replace view v(a) as select a from t where a='s'
/test_case v
/test_case v positive
/test_case v negative
/tc_domain -5 5
/tc_size 10 10
/test_case v
/tc_size 5 5
/tc_domain 0 6
/test_case v
create or replace view v(a) as select * from t where a<'x' or a>'y'
/test_case v
create or replace table t(a int primary key)
% The following should allow PTC,NTC but no PNTC
create or replace view v(a) as select a from t where a=1 and not exists (select a from t where a<>1)
/tc_domain -5 5
/tc_size 1 5
% No PNTC
/test_case v
% Single PTC
/test_case v positive
% Multiple NTCs
/test_case v negative
%
% DUPLICATES
%
/abolish
%/sql
drop database
y
/duplicates on
/assert t(1)
/assert t(1)
/assert s(1)
/assert s(1)
/assert s(1)
/assert s(X):-r(X)
/assert v(X):-t(X),s(X)
/assert r(1)
/assert r(1)
/assert r(X):-r(X)
/assert r(X):-s(X)
/listing
/datalog
t(X)
s(X)
v(X)
r(X)
/duplicates off
%
% TRACERS
%
/abolish
%/sql
drop database
y
create or replace table t(a int, b string)
create or replace table s(a int, b string)
create or replace view v1_2(a) as select a from t
create or replace view v2_2(a) as select a from s
create or replace view v3_2(b) as select b from t
create or replace view v4_2(b) as select b from s
create or replace view v1_1(a) as select t1.a from v1_2 t1,v2_2 t2 where t1.a=t2.a
create or replace view v2_1(b) as select t1.b from v3_2 t1,v4_2 t2 where t1.b=t2.b
create or replace view v(a,b) as select * from v1_1,v2_1
insert into t values (1,'1')
insert into t values (2,'2')
insert into s values (1,'1')
insert into s values (2,'2')
select * from t
select * from s
select * from v
/trace_sql v
n
/trace_datalog v(X,Y)
n
drop database
y
%
% Integrity constraints
%

% Types
:- type(p,[int,string])
/dbschema
:- type(p,[string,string])
/dbschema
:- type(p,[int,int])
/dbschema
:- type(p,[a:int,b:string])
/dbschema
% Error, several arities:
:- type(p,[a:int])
drop table p
/dbschema p
:-type(p,[int,string])
% Next, type mismatch
/assert p(a,b)
/assert p(1,a)
p(X,Y)
select * from p
% Next, type mismatch
insert into p values('a','b')
% Next, syntax error:
select $1 from p
select "$1" from p
drop table p
:-type(p(char(1)))
/assert p('1')
% Next, type mismatch
/assert p(1)
% Next, type mismatch
/assert p('11')
:-type(p(char(2)))
% Now, ok
/assert p('11')
% Next, type mismatch
:-type(p(char(1)))
% Next, type mismatch
:-type(p(varchar(1)))
% Next ok
:-type(p(varchar))
/assert p('11111111111')
/assert t(1)
/assert t(a)
:-type(t,[int])
/assert s(a)
/assert t(X):-s(X)
% Next, error
:-type(t,[int])
:-type(a,[])
:-type(a)   
/dbschema a
%
% Nullability (Existency)
drop database
y
:-type(p,[a:int,b:string])
:-nn(p,[a])
% Error, trying to assert a null:
/assert p(null,'')
/dbschema 
:-pk(p,[a])
% Error, no column:
:-pk(p,[c]) 
:-pk(p,[a,a])  
% Error, cannot change type
:-type(p,[a:int,b:string])
%
% Primary Keys
drop database
y
:-type(p,[a:int,b:string])
:-pk(p,[a])
/dbschema 
:-pk(p,[a])
% Error, no column:
:-pk(p,[c]) 
:-pk(p,[a,a])  
% Error, cannot change type
:-type(p,[a:int,b:string])
%
% Candidate Keys (Uniqueness)
drop database
y
:-type(p,[a:int,b:string])
:-ck(p,[a])  
:-ck(p,[b])
:-ck(p,[a,b])
/dbschema p
%
% Foreign Keys
drop database
y
% Error, not yet defined:
:-fk(p,[a],q,[b])    
:-type(p,[a:int]), type(q,[b:int])
% Error, pk:
:-fk(p,[a],q,[b])
:-pk(q,[b]) 
:-fk(p,[a],q,[b])
% Error, reassert:
:-fk(p,[a],q,[b])
/dbschema
% Error FK violation:
/assert p(1)
/assert q(1)
/assert p(1)
/listing
drop database
y
:-type(p,[a:int])
:-type(q,[b:int])
:-type(r,[a:int,b:int,c:string])
:-pk(p,[a]), pk(q,[b])
:-fk(r,[a],p,[a]), fk(r,[b],q,[b])
/dbschema r
% Error, type mismatch
:-fk(r,[c],q,[b])
% Save ddb
/dbschema
/save_ddb force ddb.pl
drop database
y
/dbschema
/restore_ddb ddb.pl
/dbschema
% Next error, pending fk
/drop_ic :-pk(p,[a])
/drop_ic :-fk(r,[a],p,[a])
/drop_ic :-pk(p,[a])
/drop_ic :-fk(r,[b],q,[b])
/drop_ic :-type(p,[a:int])
/drop_ic :-type(q(b:int))
/dbschema
%
% Functional Dependency
drop database
y
% Error, not yet typed:
:-fd(p,[a],[c])   
:-type(p,[a:int,b:int])
% Error, unknown column:
:-fd(p,[a],[c])  
:-fd(p,[a],[b])    
/dbschema p
/assert p(1,2)
% Error, fd violation:
/assert p(1,3)
/cat examples/family.dl
/type examples/fib.dl
drop database
y
create table a(x int)
create table b(y int)
create view v(x,y) as select * from a left join b on x=y where x>1
/development on
/dbschema v
/development off
/pwd
/shell cd
/cd ..
/pwd
/shell cd
/shell dir ..\
/shell dir examples
/shell type Debug\a.dl
/shell xcopy Debug\a.dl . /y
/shell copy Debug\a.dl . /y
/shell del q /q
% User input needed:
%/shell xcopy Debug\a.* q
/shell copy Debug\a.* q
/prolog_system
% DISTINCT operator
/abolish
drop database
y
/duplicates on
/assert p(a)
/assert p(a)
/assert p(b)
/assert p(X) :- p(X)
/assert p(X) :- p(X)
p(X)
distinct(p(X))
/abolish
/duplicates on
/assert p.
/assert p.
/assert q.
/assert q.
/assert pq:-p,q.
/assert qp:-q,p.
/assert dp:-distinct(p).
/assert dq:-distinct(q).
/assert dpdq:-distinct(p),distinct(q).
/assert dpp:-distinct(p),p.
/assert pdp:-p,distinct(p).
/assert pdq:-p,distinct(q).
/assert qdp:-p,distinct(q).
distinct(p)
distinct(q)
pq
qp
dp
dq
dpdq
dpp
pdp
pdq
qdp
:-type(p).
select distinct * from p;
drop database
y
:-type(taras(a:int))
create view tapas(a) as select * from taras
% Next, error: unknown table/view. Suggestions displayed
select a from tacas
% Next, error: unknown table. Suggestions displayed
insert into taras1 values (1)
% Next, error: unknown view. Suggestions displayed
drop view taras
% Next, error: unknown column
select b from taras
% Next, error: unknown column
select a from taras where b=1
% Next, error: unknown column
select a from taras group by b
% Next, error: unknown column
select a from taras group by a having sum(b)=1
% Next, error: unknown column
select t1.a from taras t1 inner join taras t2 on t1.a=t2.b
-- Batch file corresponding to the examples in:
-- "From Relational to Deductive Databases", F. Sáenz-Pérez, JISBD 2011.
-- April, 2011.
/datalog
drop database
y
/show_compilations on
CREATE TABLE s(sno INT, name VARCHAR(20));
:-type(s(sno:int, name:varchar(20))).
-- Not described in the paper, but useful (and some needed) for executing
-- examples
CREATE TABLE employee(Name VARCHAR(20), Department VARCHAR(20), Salary INT);
CREATE TABLE q(sno INT, name VARCHAR(20));
CREATE TABLE sp(sno INT, pno INT);
/assert sp(1,1)
/assert sp(1,2)
/assert sp(2,1)
/assert sp(2,3)
/assert q(3,'3rd Supplier')
/assert employee('Peters','Planning',2000).
/assert employee('Sanders','Sales',1200).
/assert employee('Steel','Sales',null).
/assert edge(1,2)
/assert edge(2,3)
insert into employee values('Scott','Sales',1500);
/assert employee('Smith','Sales',1500).
insert into s values(1,'1st Supplier');
insert into s select sno+1,'2nd Supplier' from s;
projection(Y) :- s(X,Y).
WITH projection(name) AS (SELECT name FROM s) SELECT * FROM projection;
s(1,Y)
SELECT name FROM s WHERE sno=1
s(X,Y), sp(U,V)
SELECT * FROM s, sp
inner_join(X,Y,V) :- s(X,Y), sp(X,V)
SELECT * FROM s NATURAL INNER JOIN sp
s(X,Y) ; q(X,Y)
SELECT * FROM s UNION SELECT * FROM q;
s(X,Y), not(q(X,Y))
SELECT * FROM s EXCEPT SELECT * FROM q
lj(s(X,Y),sp(U,V),X=U)
SELECT * FROM s LEFT JOIN sp ON s.sno=sp.sno
lj(s(X,Y),sp(U,Y),X=U)
SELECT * FROM s LEFT JOIN sp ON s.sno=sp.sno WHERE name=pno
lj(s(X,Y),rj(q(U,V),sp(Z,W),U=Z),X=U)
SELECT * FROM s LEFT JOIN (q RIGHT JOIN sp ON q.sno=sp.sno) ON s.sno=q.sno
lj(s(X,Y),rj(q(U,Y),sp(Z,Y),U=Z),X=U)
SELECT * FROM s LEFT JOIN (SELECT * FROM q RIGHT JOIN sp ON q.sno=sp.sno WHERE q.name=sp.pno) v ON s.sno=v.sno WHERE s.name=v.name
group_by(employee(N,D,S), [D], R=count)
SELECT Department,COUNT(*) FROM employee GROUP BY Department
group_by(employee(N,D,S), [D], R=count(S))
SELECT Department,COUNT(Salary) FROM employee GROUP BY Department
group_by(employee(N,D,S), [D], count(S)>1)
SELECT Department FROM employee GROUP BY Department HAVING COUNT(Salary)>1
group_by((employee(N,D,S),S>1000), [D], (C=count(S),A=avg(S)))
SELECT Department,COUNT(Salary),AVG(Salary) FROM employee WHERE Salary>1000 GROUP BY Department
group_by(employee(N,D,S),[D],(C=count(S);C=sum(S)))
SELECT Department,COUNT(Salary) FROM employee GROUP BY Department UNION SELECT Department,SUM(Salary) FROM employee GROUP BY Department
count(employee(N,D,S),S,T)
SELECT COUNT(Salary) FROM employee
v(D,C) :- count(employee(N,D,S),S,C)
SELECT Department,COUNT(Salary) FROM employee GROUP BY Department
v(D,C) :- count((employee(N,D,S),avg(employee(N1,D1,S1),S1,A),S>A),C)
% Next, type error (salary: int > avg(salary): float)
SELECT Department,COUNT(Salary) FROM employee WHERE Salary > (SELECT AVG(Salary) FROM employee) GROUP BY Department
SELECT Department,COUNT(Salary) FROM employee WHERE FLOAT(Salary) > (SELECT AVG(Salary) FROM employee) GROUP BY Department
v(D,C) :- count((employee(N,D,S),avg(employee(N1,D,S1),S1,A),S>A),C)
SELECT Department,COUNT(*) FROM employee e1 WHERE FLOAT(e1.Salary) > (SELECT AVG(Salary) FROM employee e2 WHERE e1.Department=e2.Department) GROUP BY Department
CREATE TABLE edge(Origin INT,Destination INT); 
CREATE OR REPLACE VIEW shortest_paths(Origin,Destination,Length) AS WITH RECURSIVE path(Origin,Destination,Length) AS (SELECT edge.*,1 FROM edge) UNION (SELECT path.Origin,edge.Destination,path.Length+1 FROM path,edge WHERE path.Destination=edge.Origin and path.Length < (SELECT COUNT(*) FROM edge) ) SELECT Origin,Destination,MIN(Length) FROM path GROUP BY Origin,Destination;
SELECT * FROM shortest_paths;
/assert path(X,Y,1) :- edge(X,Y).
/assert path(X,Y,L) :- path(X,Z,L0), edge(Z,Y), count(edge(A,B),Max), L0<Max, L is L0+1.
shortest_paths(X,Y,L) :- min(path(X,Y,Z),Z,L).
% Natural outer joins
/abolish
create table t(a int, b int);
create table s(a int, c int);
create table u(a int, b int);
/show_compilations on
/assert t(1,10)
/assert t(2,20)
/assert s(2,200)
/assert s(3,300)
/assert u(1,1000)
/assert u(3,3000)
select * from t natural full join s;
select * from (t natural full join s) left join u on t.a=u.a;
select * from (t natural full join s) left join u on s.a=u.a;
select * from (t natural full join s) left join u on 10*s.c=u.b;
select * from (t natural full join s) left join u on 10*s.c=u.b or 100*t.b=u.b;
select * from (t natural full join s) natural full join u;
% Compound negations
not(not(not(a)))
not(not(a))
not((a,b))
not((a;b))
not(1<0)
not(not(1<0))
not(1\=0)
% SAFETY and set variables: distinct/2 and aggregates
% distinct
/abolish
drop database
y
/duplicates on
/safe off
/assert t(0,0)
/assert t(0,1)
/assert t(1,0)
/assert t(2,0)
/assert p(1)
% Next, ok:
distinct([X,X],t(X,Y))
% Next, syntax error:
distinct([X,Y],t(X))
% Next, ok:
distinct([X],t(X,Y)),Y=1
% Next, ok (t is automatically grouped by Y):
/assert v(A,Y):-avg(t(X,Y),Y,A)
% Next, warning (set variables in head are not allowed to be called as non-ground):
/assert v(C,Y):-group_by(t(X,Y),[X],C=count)
% Next, error (set variables are not allowed in a view head), execution discarded:
v(X,Y):-group_by(t(X,Y),[X],C=count(X))
% Next, error, execution discarded:
/assert v(C):-count(t(X,Y),C),Y=1
% Next, error, execution discarded:
group_by(t(X,Y),[X],C=count),p(Y)
% Next, error, execution discarded:
group_by(t(X,Y),[X],C=count(X)+Y) 
% Next, error, execution discarded:
group_by(t(X,Y),[X],C=count),Y>1
/safe on
% Next, ok (reordered):
/assert v(C):-count(t(X,Y),C),Y=1
% Next, ok (reordered):
group_by(t(X,Y),[X],C=count),p(Y)
% Next, error, execution discarded:
group_by(t(X,Y),[X],C=count(X)+Y) 
% Next, error, execution discarded:
group_by(t(X,Y),[X],C=count),Y>1
% Next, error, execution discarded:
distinct([X],sp(X,Y)),Y>1
% Null-related comparisons and expressions
/abolish
/safe off
/development on
% True:
X=null,X=X             
% False:
X=null,X\=X   
% True:
X is null,X=X 
% False:
X is null,X\=X
% True:
X=null,Y=X    
% True:
X=null,Y is X 
% True:
X=null,X+1=X+1
% False:
X=null,X+1=1+X
% False:
X=null,Y=null,X=Y
% False:
X=null,Y=null,X\=Y
% True:
X=null,Y=X,X+1=Y+1
% False:
X=null,Y=X,X+1=1+Y
% Exception:
X=null,X+1=Y+1,Y=X
/safe on
% True:
X=null,X+1=Y+1,Y=X
%
% TAPI
%
/tapi_log on
/sql_left_delimiter
/tapi /sql_left_delimiter
/sql_right_delimiter
/tapi /sql_right_delimiter
/tapi /test_tapi
/use_db $des
/tapi /use_db $des
/tapi /open_db mysql
/show_dbs
/tapi /show_dbs
/tapi /close_db
/tapi create table "t"("a" int)
/tapi create view "v"("a") as select * from "t"
/tapi create or replace table "t"("a" int)
% Next, error
/tapi drop view vv
/tapi drop view v
/tapi drop table t
/tapi create table [t]([a] int)
/tapi insert into "t" values(1)
/tapi update t set a=2 where a=1
/tapi update t set a=2 where a=1
/tapi create view "v"("a") as select * from "t"
/tapi rename table t to s
/tapi /relation_exists t
/tapi /relation_exists s
/tapi /list_table_schemas
/tapi /list_view_schemas
/tapi :-pk(s,[a])
/tapi :-nn(s,[a])
/tapi /list_table_constraints s
/tapi /relation_schema s
/tapi /is_empty s
/tapi /is_empty v
/tapi select * from s
/tapi delete from "s"
/tapi delete from "s"
/tapi /is_empty v
/tapi :-type(u(a:int))
/tapi :-fk(u,[a],s,[a])
/tapi /dependent_relations s
/tapi /dependent_relations s/1
/tapi /dependent_relations s/2
/tapi /referenced_relations s
/tapi /referenced_relations s/1
/tapi /referenced_relations s/2
% Next, 3 errors
/tapi insert into "s" values(1,1)
/tapi insert into "s" values('1')
/tapi select * from s where a='1'
/tapi drop database
/p debug/des_tapi_sql_debug
/abolish
/multiline off
/development on
% Top-N queries
% Datalog
/duplicates off
p(X):-X=1;top(3,(p(Y),X=Y+1))
/assert p(X):-X=1;p(Y),X=Y+1
top(10,p(X))
/duplicates on
top(10,p(X))
/duplicates off
/assert even(X):-X=0;odd(Y),X is Y+1
/assert odd(X):-even(Y),X is Y+1
top(10,even(X))
/duplicates on
top(10,even(X))
/duplicates off
/abolish even
/abolish odd
/assert even(X):-X=0;top(3,odd(Y)),X is Y+1
/assert odd(X):-top(2,even(Y)),X is Y+1 
even(X)
odd(X)
/assert t(1)
/assert t(2)
/assert v(X,Y):-t(X),t(Y)
/assert tt(N,X,Y):-top(N,v(X,Y)) 
t(X)
v(X,Y)
top(1,v(X,Y))
tt(2,X,Y)
tt(3,X,Y)
tt(4,X,Y)
tt(5,X,Y)
t(X),top(1,t(Y))
top(1,t(X)),top(1,t(Y))
top(1,t(X)),t(Y)
t(X),top(2,t(Y))
top(2,t(X)),top(1,t(Y))
top(2,t(X)),top(2,t(Y))
top(1,t(X)),top(2,t(Y))
top(2,t(X)),t(Y)
top(3,t(X)),top(4,t(Y))
/assert t(1)
/assert t(1)
/retract t(1)
tt(5,X,Y)    
/duplicates on
tt(5,X,Y)     
tt(50,X,Y)
/listing
v(X,Y)
t(X),t(Y)
top(3,(t(X),t(Y)))
top(30,(t(X),t(Y)))
/assert tt1(N,X,Y):-top(N,(t(X),t(Y)))
tt1(30,X,Y)
tt1(3,X,Y) 
tt1(7,X,Y)
/duplicates off
/abolish
/assert p(1).
/assert p(X):-p(Y),Y<10,X=Y+1.
top(1,p(X))
top(2,p(X))
top(3,p(X))
top(1,p(X)), top(3,p(Y))
top(3,p(X)), top(1,p(Y))
top(1,p(X)), top(3,p(X))
top(3,p(X)), top(1,p(X))
top(3,p(X)), top(1,p(Y)), X=Y
top(1,p(X)), p(X)
p(X), top(1,p(X))
p(X), top(1,p(Y)), X=Y
top(1,p(Y)), p(X)
p(X), top(1,p(Y))
top(1,p(X)), top(2,p(X))
top(2,p(X)), top(1,p(X))
/abolish
/assert p(1).
/assert p(X):-p(Y),X=Y+1.
top(1,p(X))
top(2,p(X))
top(3,p(X))
top(1,p(X)), top(3,p(Y))
top(3,p(X)), top(1,p(Y))
% top(1,p(X)), top(3,p(X)) This should not terminate
top(3,p(X)), top(1,p(X))
top(3,p(X)), top(1,p(Y)), X=Y
/abolish
(n(X):-X=0;n(Y),X=Y+1) => top(3,n(X)).
(n(X):-X=0;n(Y),X=Y+1) => top(3,(n(X),X\=0)).
top(3,(n(X):-X=0;n(Y),X=Y+1) => (n(X),X\=0)). 
(n(X):-X=0;n(Y),X=Y+1) => (top(1,(n(X),X\=0)), top(3,(n(Y),Y\=0))).
(n(X):-X=0;n(Y),X=Y+1) => (top(3,(n(X),X\=0)), top(1,(n(Y),Y\=0))).
/abolish
/assert n(X):-X=0;n(Y),X=Y+1
/assert r(X):-a=>n(X)
top(10,(r(X),X>1)).
/abolish
/assert n(A) :- r(0) /\ (r(B) :- r(C), B=C+1) => r(A).
top(1,(n(X),X>1)).
/abolish
/assert n(X):-X=0;n(Y),X=Y+1
/assert r(X):-a=>n(X)
top(1,(r(X),X>1)).
/abolish
/assert s(1)
(n(X):-X=0;n(Y),X=Y+1) => top(3,(n(X),not s(X))).
(n(X):-X=0;n(Y),X=Y+1) => (top(3,n(X)),not s(X)).
/assert n(X):-X=0;n(Y),X=Y+1
top(3,(n(X), not s(X))).
/assert numbers(A) :- (n(0) /\ (n(B) :- n(C),B=C+1)) => n(A).
top(3,(numbers(X),not s(X))).
/abolish
/assert s(1)
/assert numbers(A) :- (n(0) /\ (n(B) :- numbers(C),B=C+1)) => n(A).
top(3,(numbers(X),not s(X))).
/duplicates on
%
% Relational algebra
%
/abolish
/show_compilations on
/show_sql on
create table dpto(nd int primary key, nomd string);
create table emp(dni string primary key, numdep int references dpto(nd));
insert into dpto values (1,'Ventas'), (2,'Contabilidad');
insert into emp values ('123',1), ('456',2), ('235',2), ('987',1);
-- DNI de empleados que trabajan en "Contabilidad" de tres formas distintas:
res := project dni (select numdep=nd and nomd='Contabilidad' (emp product dpto));
select true (res);
r1 := select nomd='Contabilidad'(dpto);
r2 := project nd (r1);
r3 := emp product r2;
r4 := select numdep=nd (r3);
res := project dni (r4);
select true (res);
res := project dni (select numdep=nd (emp product project nd (select nomd='Contabilidad'(dpto))))
select true (res);
/abolish
create table dpto(num int primary key, nomd string);
create table emp(dni string primary key, num int references dpto);
insert into dpto values (1,'Ventas'), (2,'Contabilidad');
insert into emp values ('123',1), ('456',2), ('235',2), ('987',1);
-- DNI de empleados que trabajan en "Contabilidad" con renombramiento:
r1 := select nomd='Contabilidad'(dpto);
r2 := rename v(numdep) (project num (r1));
r3 := emp product r2;
r4 := select num=numdep (r3);
res := project dni (r4);
select true (res);
res := project dni (select num=numdep (emp product rename v(numdep) (project num (select nomd='Contabilidad'(dpto)))));
select true (res);
/abolish
-- Nombre de empleados que trabajan en proyectos dirigidos por "López" de tres formas distintas:
create table emp(dni string primary key, nom string);
create table proy(np int primary key, director string);
create table trabaja(dnie string references emp(dni), npro int references proy(np), primary key(dnie,npro));
insert into emp values ('123','López'), ('456','Agudo'), ('235','Ludeña'), ('987','Pérez');
insert into proy values (1,'López'), (2,'Ludeña');
insert into trabaja values ('123',1), ('456',1), ('235',2), ('987',2);
res := project nom (select np=npro and dni=dnie and director='López' (emp product proy product trabaja));
select true (res);
r1 := project np (select director='López' (proy));
r2 := trabaja product r1;
r3 := select np=npro (r2);
r4 := project dnie (r3);
r5 := r4 product emp;
r6 := select dni=dnie (r5);
res := project nom (r6);
select true (res);
res := project nom (select dni=dnie (project dnie (select np=npro (trabaja product project np (select director='López' (proy)))) product emp));
select true (res);
/abolish
create table emp(dni string primary key, sueldo int, dnisupervisor string, check dnisupervisor in select dni from emp);
insert into emp values ('987',2500,'987'), ('456',2000,'456'), ('123',1000,'456'), ('235',1000,'987'), ('567',800,'123'), ('678',600,'567'), ('789',500,'678');
emp1 := rename v(dni1,s1,dni_s1) (emp);
r1 := emp product emp1;
r2 := select dnisupervisor=dni1 and s1>2000 and dni<>dnisupervisor (r1);
res := project dni (r2);
select true (res);
res := project dni (select dnisupervisor=dni1 and s1>2000 and dni<>dnisupervisor (emp product emp1));
select true (res);
r1 := select sueldo>2000 (emp);
r2 := rename v(dni_s) (project dni (r1));
r3 := emp product r2;
r4 := select dnisupervisor=dni_s and dni<>dnisupervisor (r3);
res := project dni (r4);
select true (res);
res := project dni (select dnisupervisor=dni_s and dni<>dnisupervisor (emp product rename v(dni_s) (project dni (select sueldo>2000 (emp)))));
select true (res);
res := project dni (select ds=dni and sueldo>2000 and d<>ds (rename v(d,s,ds) (emp) product emp));
select true (res);
create or replace table hijo(dni string, nom string, primary key(dni, nom));
insert into hijo values ('987','Pepito'), ('456','Juanito'), ('456','Josito'), ('123','Pedrito'), ('123','Petunia'), ('123','Paz');
res := project dni (select dni1=dni and nom<>nom1 (hijo product rename v(dni1,nom1) (hijo)));
select true (res);
sup_directo := rename v(dni1) (project dni (select dnisupervisor='123' (emp)));
select true (sup_directo);
res := sup_directo union (project dni (select dnisupervisor=dni1 (emp product sup_directo)));
select true (res);
/abolish
create or replace table dpto(nd int primary key, nomd string);
create or replace table emp(dni string primary key, numdep int references dpto(nd));
insert into dpto values (1,'Ventas'), (2,'Contabilidad');
insert into emp values ('123',1), ('456',2), ('235',2), ('987',1);
res := project dni (emp zjoin numdep=nd select nomd='Contabilidad' (dpto));
select true (res);
create or replace table emp(dni string primary key, nd int references dpto);
insert into emp values ('123',1), ('456',2), ('235',2), ('987',1);
res := emp njoin dpto;
select true (res);
create or replace table clientes(dni string primary key, nom string, dir string);
create or replace table coches(matr string primary key, modelo string, anio int);
create or replace table propiedad(dni string references clientes, matr string references coches, primary key(dni, matr));
insert into clientes values ('1','n1','d1'),('2','n2','d2'),('3','n3','d3');
insert into coches values ('m1','Porsche 924',1980),('m2','Seat 600',1965),('m3','Ferrari F50',1983),('m4','BMWi8',2014);
insert into propiedad values ('1','m1'),('2','m2'),('3','m3'),('3','m4');
res := project nom (clientes njoin propiedad njoin select modelo='Ferrari F50' (coches));
select true (res);
/abolish
create table emp(dni string primary key, nom string);
create table trab(dni string references emp, npro int, primary key(dni,npro));
insert into emp values ('123','López'), ('456','Agudo'), ('235','Ludeña'), ('987','Pérez');
insert into trab values ('123',1), ('123',2), ('456',1), ('235',1), ('235',2), ('987',1), ('987',2), ('987',3);
res := trab division project npro (select dni='123' (trab));
select true (res);
create or replace table trab(dni string references emp, npro int, nhoras int, primary key(dni,npro));
insert into trab values ('123',1,2), ('123',2,1), ('456',1,3), ('235',1,4), ('235',2,3), ('987',1,2), ('987',2,1), ('987',3,1);
res := project dni,npro (trab) division project npro (select dni='123' (trab));
select true (res);
/abolish
create table credit_info(customer_name string, limit int, credit_balance int);
insert into credit_info values ('n1',100,90), ('n2',1000,900), ('n3',5000,1000);
project customer_name,limit-credit_balance (credit_info);
/abolish
create table r(a int, b int);
create table s(a int);
/duplicates on
/assert r(1,2)
/assert r(1,2)
/assert s(1)
r product s
r njoin s
r union r
/ra distinct (r)
/abolish
create table r(a int, b int, c int);
/assert r(1,1,7)
/assert r(1,2,7)
/assert r(2,2,3)
/assert r(2,2,10)
group_by [] sum(c) true (r);
/abolish
create table account(branch_name string, account_number string, balance int);
/assert account('Perryridge','A-102',400)
/assert account('Perryridge','A-201',900)
/assert account('Brighton','A-217',750)
/assert account('Brighton','A-215',750)
/assert account('Redwood','A-222',700)
group_by branch_name branch_name,sum(balance) true (account);
sort branch_name, balance (account);
sort branch_name asc, balance desc (account) ;
top 3 (account);
/abolish
create or replace table dpto(nd int primary key, nomd string);
create or replace table emp(dni string primary key, nd int);
insert into dpto values (1,'Ventas'), (2,'Contabilidad'), (3,'Marketing');
insert into emp values ('123',1), ('456',2), ('235',2), ('987',4);
res := emp njoin dpto;
select true (res);
project dni,emp.nd nd,nomd (emp rjoin emp.nd=dpto.nd dpto);
project dni,emp.nd nd,nomd (emp ljoin emp.nd=dpto.nd dpto);
emp nrjoin dpto;
emp nljoin dpto;
nat(n) := project 0 (dual) union project n+1 (nat);
SELECT TOP 5 * FROM nat; 
factorial(n,f) := project 0,1 (dual) union project n+1,(n+1)*f (factorial);
SELECT TOP 5 * FROM factorial;
/multiline on
:-type(tiene_jefe(emp:string,jefe:string)).
insert into tiene_jefe values ('a','b'),('b','c'),('c','d');
jefe(emp,jefe) := project emp,jefe (tiene_jefe) union 
       project e1,j2 
       (rename j1(e1,j1) (tiene_jefe) zjoin j1=e2
        rename j2(e2,j2) (jefe));
select * from jefe;
jefe(emp,jefe) := project emp,jefe (tiene_jefe) union 
       project e1,j2 
       (rename j1(e1,j1) (jefe) zjoin j1=e2
        rename j2(e2,j2) (jefe));
select * from jefe;
/multiline off
impar(x):= select true (impar); 
par(x)  := project 0 (dual) union project x+1 (impar);
impar(x):= project x+1 (par);
select top 5 * from par;
select top 5 * from impar;
/abolish
/show_sql off
/duplicates off
%
% Tuple Relational Calculus
%
create table t(a int)
/trc
{1|t(X)}
{1|exists X t}
{1|exists X,X t(X)}
{1|exists X exists X t(X)}
{1|(exists X t(X)) and t(X)}
{1|t(X) and exists X t(X)}           
{X,Y|t(X)}
{X|exists X t(X)} 
{1|not t(X)}
{1|forall X t}
{1|forall X,X t(X)}
{1|forall X forall X t(X)}
{1|(forall X t(X)) and t(X)}
{1|t(X) and forall X t(X)}           
-- OK:
{1|exists X t(X)}
{1|exists X t(X) and t(X)}
{1|forall X t(X)}
{1|forall X t(X) and t(X)}
/p examples/division.trc
%
% Domain Relational Calculus
%
create table t(a int)
/drc
{1|t(X)}
{1|exists X t}
{1|exists X,X t(X)}
{1|exists X exists X t(X)}
{1|(exists X t(X)) and t(X)}
{1|t(X) and exists X t(X)}           
{X,Y|t(X)}
{X|exists X t(X)} 
{1|not t(X)}
{1|forall X t}
{1|forall X,X t(X)}
{1|forall X forall X t(X)}
{1|(forall X t(X)) and t(X)}
{1|t(X) and forall X t(X)}           
-- OK:
{1|exists X t(X)}
{1|exists X t(X) and t(X)}
{1|forall X t(X)}
{1|forall X t(X) and t(X)}
/p examples/division.drc
/abolish
/duplicates on
/compact_listings on
% Minimal example for demonstrating a problem using the function 'rename'
% in relational algebra context.
% ITShop
%
CREATE TABLE manufacturer (name string, model int,   type string);
CREATE TABLE pc           (model int,   ram int,     price int);
CREATE TABLE printer      (model int,   type string, price int);
% manufacturer
%                                 name      model  type
INSERT INTO manufacturer VALUES ('Banana',  1001, 'PC');
INSERT INTO manufacturer VALUES ('Doll',    1002, 'PC');
INSERT INTO manufacturer VALUES ('Fijutsi', 3003, 'Printer');
INSERT INTO manufacturer VALUES ('GO',      3005, 'Printer');
% PC
%                      model ram   price
%
INSERT INTO pc VALUES (1001, 2048, 2114);
INSERT INTO pc VALUES (1002, 1024,  998);
% Printer
%                           model  type    price
%
%INSERT INTO printer VALUES (1001, 'PC',    99);
INSERT INTO printer VALUES (3003, 'ink',    99);
INSERT INTO printer VALUES (3005, 'laser', 899);
% looking for a list of manufacturers and their produced pcs (works):
manufacturer njoin pc;
% looking for a list of manufacturers and their produced printes (can' work)
% result is an empty answer because the njoin joins over both attributes
% 'model' and 'type'.
manufacturer njoin printer
% trying to solve the problem by renaming the attribute 'type' of relation 'printer'
% into 'type2' and renaming the relation into 'printer2', too.
% projecting onto the new attribute-name works and gives the expected result:
project type2 (rename printer2 (model,type2,price) (printer));
% natural-joining did not work
manufacturer njoin (rename printer2 (model,type2,price) (printer));
% of course creating a new view printer2 by assigning works
printer2 (model,type2,price) := printer;
manufacturer njoin printer2;
/multiline on
/abolish
/duplicates off
create table employee (eID string primary key, eLast string, eFirst string, eTitle string, eSalary int);
create table technologyArea(aID string primary key, aTitle string, aURL string, aLeadID string);
create table trainingCourse(cID string primary key, cTitle string, cHours int, areaID string);
create table takes(eID string, cID string, tYear int, tMonth int, tDay int, primary key (eID, cID));

insert into employee values ('111','Last111','First111','Database Administrator',75111);
insert into employee values ('222','Last222','First222','Software Engineer',51722);
insert into employee values ('321','Last321','First321','Database Administrator',68321);
insert into employee values ('333','Last333','First333','Sr Software Engineer',60333);
insert into employee values ('345','Last345','First345','Sr Software Engineer',59345);
insert into employee values ('369','Last369','First369','Software Engineer',36369);
insert into employee values ('444','Last444','First444','Software Engineer',44444);
insert into employee values ('456','Last456','First456','Software Engineer',45456);
insert into employee values ('555','Last555','First555','Sr Software Engineer',55555);
insert into employee values ('654','Last654','First654','Coach',60654);
insert into employee values ('666','Last666','First666','Coach',66666);
insert into employee values ('678','Last678','First678','Coach',67678);
insert into employee values ('693','Last693','First693','Coach',69693);
insert into employee values ('777','Last777','First777','Database Administrator',77777);
insert into employee values ('789','Last789','First789','Database Administrator',78789);
insert into employee values ('888','Last888','First888','Database Administrator',88888);
insert into employee values ('963','Last963','First963','Manager',98963);
insert into employee values ('987','Last987','First987','Manager',99987);
insert into employee values ('999','Last999','First999','Manager',100999);

insert into technologyArea values ('DB','Database','http://www.company.intranet/technology/db','321');
insert into technologyArea values ('JA','Java','http://www.company.intranet/technology/java','333');
insert into technologyArea values ('SE','Software Engineering','http://www.company.intranet/technology/software','345');
insert into technologyArea values ('WW','Web','http://www.company.intranet/technology/web','369');

insert into trainingCourse values ('DB01','Microsoft Access',8,'DB');
insert into trainingCourse values ('DB02','Query Languages',16,'DB');
insert into trainingCourse values ('DB03','Database Modeling',8,'DB');
insert into trainingCourse values ('DB04','Transactions',8,'DB');
insert into trainingCourse values ('JA01','Introduction to Java',8,'JA');
insert into trainingCourse values ('JA02','JavaBeans',16,'JA');
insert into trainingCourse values ('JA03','Enterprise JavaBeans',32,'JA');
insert into trainingCourse values ('JA04','JDBC',8,'JA');
insert into trainingCourse values ('SE01','Patterns',16,'SE');
insert into trainingCourse values ('SE02','Validation & Verification',32,'SE');
insert into trainingCourse values ('SE03','Software Components',40,'SE');
insert into trainingCourse values ('WW01','Dynamic HTML',8,'WW');
insert into trainingCourse values ('WW02','XML',16,'WW');
insert into trainingCourse values ('WW03','XSLT',24,'WW');

insert into takes values ('321','JA01',2000,7,24);
insert into takes values ('333','JA04',2000,7,27);
insert into takes values ('333','SE01',2000,6,1);
insert into takes values ('345','SE01',2000,6,1);
insert into takes values ('345','SE02',2000,6,2);
insert into takes values ('345','WW01',2000,8,1);
insert into takes values ('369','JA04',2000,7,27);
insert into takes values ('369','WW01',2000,8,1);
insert into takes values ('369','WW02',2000,8,2);
insert into takes values ('369','WW03',2000,8,3);
insert into takes values ('444','DB01',2000,5,1);
insert into takes values ('444','DB02',2000,9,15);
insert into takes values ('456','JA01',2001,1,15);
insert into takes values ('456','WW01',2001,3,1);
insert into takes values ('555','DB03',2000,9,22);
insert into takes values ('666','JA01',2000,1,1);
insert into takes values ('678','JA01',2000,1,1);
insert into takes values ('678','JA02',2000,1,2);
insert into takes values ('693','JA01',2000,7,24);
insert into takes values ('693','JA02',2000,1,2);
insert into takes values ('693','JA03',2000,12,12);
insert into takes values ('693','JA04',2000,12,4);
insert into takes values ('777','DB01',2000,5,1);
insert into takes values ('777','DB02',2000,9,15);
insert into takes values ('777','DB03',2000,9,22);
insert into takes values ('777','DB04',2000,9,29);
insert into takes values ('789','WW01',2001,3,1);
insert into takes values ('888','DB01',2000,5,1);
insert into takes values ('888','JA01',2000,7,24);
insert into takes values ('888','SE01',2000,6,1);
insert into takes values ('888','WW01',2000,8,1);
insert into takes values ('987','JA01',2000,7,24);
insert into takes values ('999','DB01',2000,5,1);
insert into takes values ('999','SE01',2000,6,1);

% Relational Algebra: Fundamental EMPLOYEE TRAINING Queries

qSelection :=
    select  eSalary > 100000 (employee);

qProjection :=
    project eLast, eFirst, eTitle (employee);

qUnion :=
    (project eID (select  eTitle = 'Manager' (employee)))  union  
    (project eID (select  eTitle = 'Coach' (employee)));

% Alternative for qUnion: using or in selection condition
qUnionA :=
    project eID (select  eTitle = 'Manager'  or  eTitle = 'Coach' (employee));

qDifference :=
    (project eID (select eTitle='Manager' (employee))) difference (project eID (takes));

qProduct :=
    (project eID (employee)) product (project cID (trainingCourse));

% Relational Algebra: Additional EMPLOYEE TRAINING Queries

qIntersection :=
    (project eID (select eTitle='Manager'(employee))) intersect (project eID (takes));

% The generic join is not supported by the educational tool by design,
% forcing its equivalent definition in terms of the fundamental relational algebra operators;
qJoin :=
    select eID = aLeadID (employee product technologyArea);

qNaturalJoin :=
    project cTitle, tYear, tMonth, tDay (trainingCourse njoin takes);

% Division: see query Q6 below (see also the separate ABSTRACT DIVISION enterprise)

% Intermediate Tables

managers := 
     project eID (select eTitle='Manager' (employee));
takenCourse := 
    project eID (takes);
qIntersectionA :=
    managers intersect takenCourse;

% Renaming attributes
leads(eID) := 
    project aLeadID (technologyArea);

managersOrLeads :=
    managers union leads;

% Relational Algebra: Example EMPLOYEE TRAINING Queries

% Q1: What training courses are offered in the `Database' technology area?
%     (cID, cTitle, cHours)

dbTechArea(areaID) := 
    project aID (select aTitle='Database' (technologyArea)); 
q1 := 
     project cID, cTitle, cHours (dbTechArea njoin trainingCourse);

% Q2: Which employees have taken a training course offered in the 
%     'Database' technology area?
%     (eID, eLast, eFirst, eTitle)

dbCourseID := 
    project cID (q1);
q2 := 
     project eID, eLast, eFirst, eTitle ( (dbCourseID njoin takes) njoin employee);

% Q3: Which employees have not taken any training courses?
%     (eID, eLast, eFirst, eTitle)

alleIDs := 
    project eID (employee);
takeseIDs := 
    project eID (takes);
q3 :=  
    project eID, eLast, eFirst, eTitle ( (alleIDs difference takeseIDs) njoin employee);

% Q4: Which employees took courses in more than one technology area?  
%     (eID, eLast, eFirst, eTitle)

eIDaIDs(eID, aID) := 
    project eID, areaID (takes njoin trainingCourse);
eIDaIDsCopy(eID1, aID1) := 
    eIDaIDs;
eIDsMoreThanOne := 
    project eID (select eID=eID1 and aID <> aID1 (eIDaIDs product eIDaIDsCopy));
q4 :=  
    project eID, eLast, eFirst, eTitle (eIDsMoreThanOne njoin employee);

% Q5: Which employees have the minimum salary?
%     (eID, eLast, eFirst, eTitle, eSalary)

empSal := 
    project eSalary(employee);
empSalCopy(eSalary1) := 
    empSal;
empSalNotMin := 
    project eSalary (select eSalary > eSalary1 (empSal product empSalCopy));
empSalMin := 
    empSal difference empSalNotMin;
q5 :=   
    employee njoin empSalMin;

% Q6: Which employees took all of the training courses offered 
%     in the `Database' technology area?  
%     (eID, eLast, eFirst, eTitle)

% The division operator is not supported by the educational tool by design,
% forcing its equivalent definition in terms of the fundamental relational algebra operators.
% empsAllDB := (project eID, cID (takes)) / dbCourseID.

% Reusing q2, which finds the employees that took a Database course
allEmpWithAllDB :=
    (project eID (q2)) product dbCourseID;

empNotRelatedToSomeDB :=
    project eID (allEmpWithAllDB difference (project eID, cID (takes)));

empsAllDB :=
    (project eID (q2)) difference empNotRelatedToSomeDB;

q6 :=
    project eID, eLast, eFirst, eTitle (empsAllDB njoin employee);

% Query Optimization

% Q1 illustrates: Performing selections as early as possible

% Q1 Option A: selects Database title as early as possible
q1OptA :=
    project cID, cTitle, cHours  
	(select aID=areaID
	   ((project aID (select aTitle='Database' (technologyArea))) product trainingCourse));

% Stepwise refinement of q1OptA
q1A1 := project aID (select aTitle='Database' (technologyArea));
q1A2 := q1A1 product trainingCourse;
q1A3 := select aID=areaID (q1A2);
q1A4 := project cID, cTitle, cHours (q1A3);

% Q1 Option B: performs selection of Database title after product

q1OptB :=
    project cID, cTitle, cHours
	(select aTitle='Database'  
	    (select aID=areaID (technologyArea product trainingCourse)));

% Stepwise refinement of q1OptB
q1B1 := technologyArea product trainingCourse;
q1B2 := select aID=areaID (q1B1);
q1B3 := select aTitle='Database' (q1B2);
q1B4 := project cID, cTitle, cHours (q1B3);

% Q1: Compare size of intermediate tables in stepwise refinement of Option A versus Option B

% Q2 illustrates: Reordering of joins

% Q2 Option A: Join dbCourse with takes first
q2OptA :=
    project eID, eLast, eFirst, eTitle 
	((q1 njoin takes) njoin employee);

% Stepwise refinement of q2OptA    
q2A1 := q1 njoin takes;
q2A2 := q2A1 njoin employee;
q2A3 := project eID, eLast, eFirst, eTitle (q2A2);

% Q2 Option B: Joins with dbCourse last
q2OptB :=
    project eID, eLast, eFirst, eTitle
	(q1 njoin (takes njoin employee));

% Stepwise refinement of q2OptB
q2B1 := takes njoin employee;
q2B2 := q1 njoin q2B1;
q2B3 := project eID, eLast, eFirst, eTitle (q2B2);

% Q2: Compare size of intermediate tables in stepwise refinement of Option A versus Option B

%-----------------------------------------End EMPLOYEE TRAINING Enterprise--------------------------------------

% Queries:

/ra
select true (qSelection);
select true (qProjection);
select true (qUnion);
select true (qUnionA);
select true (qDifference);
select true (qProduct);
select true (qIntersection);
select true (qJoin);
select true (qNaturalJoin);
select true (managers);
select true (takenCourse);
select true (qIntersectionA);
select true (leads);
select true (managersOrLeads);
select true (dbTechArea);
select true (q1);
select true (dbCourseID);
select true (q2);
select true (alleIDs);
select true (takeseIDs);
select true (q3);
select true (eIDaIDs);
select true (eIDaIDsCopy);
select true (eIDsMoreThanOne);
select true (q4);
select true (empSal);
select true (empSalCopy);
select true (empSalNotMin);
select true (empSalMin);
select true (q5);
select true (allEmpWithAllDB);
select true (empNotRelatedToSomeDB);
select true (empsAllDB);
select true (q6);
select true (q1OptA);
select true (q1A1);
select true (q1A2);
select true (q1A3);
select true (q1A4);
select true (q1OptB);
select true (q1B1);
select true (q1B2);
select true (q1B3);
select true (q1B4);
select true (q2OptA);
select true (q2A1);
select true (q2A2);
select true (q2A3);
select true (q2OptB);
select true (q2B1);
select true (q2B2);
select true (q2B3);
/duplicates on
/datalog
% Recursion in RA
create table f(a int, b int);
/assert f(1,2)
/assert f(2,3)
v(c,d):=project c,b (select d=a (v product f)) union select true (f);
/ra select true (v)    
/multiline off
% Display of equivalent SQL 
/show_sql 
/show_compilations 
/show_sql off
/show_compilations off
project a (rename t(a) (project 1 (dual)))
v(a):=project a (rename t(a) (project 1 (dual)))
/show_sql on
/show_compilations off
project a (rename t(a) (project 1 (dual)))
v(a):=project a (rename t(a) (project 1 (dual)))
/show_sql off
/show_compilations on
project a (rename t(a) (project 1 (dual)))
v(a):=project a (rename t(a) (project 1 (dual)))
/show_sql on
/show_compilations on
project a (rename t(a) (project 1 (dual)))
v(a):=project a (rename t(a) (project 1 (dual)))
:-type(t(a:int))
/show_sql off
/show_compilations off
{X | t(X) and t(X)}
v(a):={X | t(X) and t(X)}
/show_sql on
/show_compilations off
{X | t(X) and t(X)}
v(a):={X | t(X) and t(X)}
/show_sql off
/show_compilations on
{X | t(X) and t(X)}
v(a):={X | t(X) and t(X)}
/show_sql on
/show_compilations on
{X | t(X) and t(X)}
v(a):={X | t(X) and t(X)}
drop table t
drop view v
/show_sql off
/show_compilations on
select c from (select 1+2 c from dual union select 5 c from dual)
/order_answer on
/assert t(3,1)
/assert t(2,2)
/assert t(1,3)
/assert t(2,1)
t(X,Y)
/order_answer off
t(X,Y)
order_by(t(X,Y),[X],[d])
order_by(t(X,Y),[X,Y],[d,a])
order_by(t(X,Y),[Y],[a])
order_by(t(X,Y),[Y,X],[a,a])
order_by(t(X,Y),[Y,X])
/order_answer on
% Unable in current DBMS's:
select 1 a, a+1
% ... even the other way round
select a+1, 1 a
% Recursive uses are not a problem:
select a b, b a
% Definitions in project list cannot be used in the where clause:
select 1 a from dual where a>0
% Autorenamings are not a problem:
create table t(a int)
insert into t values (1)
select a a from t
% Funny uses also:
create or replace table t(a int, b int)
insert into t values(1,2)
select a b, b a from t
select a from (select a b, b a from t)
select b from (select a b, b a from t)
select a+1 c, c-1 d from t
% Next will raise an exception. A chance to use constraint solving in solving equational systems
select a+1+d c, c-1 d from t
/abolish
-- Using built-ins as identifiers
create table select(from int, to int);
select * from select;
-- Next, error:
select * from from;
-- Select the "from" column from the table "select"
select from from select;
-- Select the "from" column, renaming it to "from", from the table "select". DB2 does not parse this
select from from from select;
-- Select the "from" column, renaming it to "from", from the table "select", which is renamed to itself. Should not be an error:
select from from from select select;
/abolish
/duplicates off
% Exists
/development on
/abolish
% Bad uses:
t(X), exists([X],not p(X)).
exists([X,Y],not p(X)).
exists([X,X],not p(X)).
% Normal uses:
/assert t(1).
/assert s(1).
/assert t(1,1).
/assert s(1,0).
/assert v1 :- exists([X],t(X)).
/assert v2 :- exists([X],not t(X)).
/assert v3 :- not exists([X],t(X)).
/assert v4 :- not exists([X],not t(X)).
/assert v5 :- exists([X],(t(X),not exists([Y],(s(Y),Y>X)))).
/assert v6(X) :- exists([Y],(t(X,Y),not exists([Z],(s(X,Z),Y>Z)))).
/assert v7 :- not exists([X],exists([Y],(t(X,Y),not exists([Z],(s(X,Z),Y>Z))))).
/assert v8 :- exists([X],not exists([Y],(t(X,Y),not exists([Z],(s(X,Z),Y>Z))))).
/assert v9 :- not exists([X],exists([Y],t(X,Y))).
/abolish
/assert t(1,1)
/assert t(1,2)
/assert t(2,1)
/assert s(1)
/assert s(2)
t(X,Y) division s(Y)
/abolish
/assert work(e21,p1,4).
/assert work(e21,p2,5).
/assert work(e21,p3,7).
/assert work(e22,p1,3).
/assert work(e22,p2,10).
/assert work(e22,p3,4).
/assert work(e31,p4,9).
/assert work(e31,p5,6).
/assert work(e31,p6,5).
/assert np_work(N,P) :- work(N,P,_).
np_work(N,P) division np_work(e21,P)
work(N,P,_) division work(e21,P,_)
/assert team(1,e13).
/assert team(2,e21).
/assert team(2,e22).
/assert team(3,e31).
/assert emp_p_e21(E) :- work(E,P,_) division work(e21,P,_).
/assert team_p_e21(T) :- team(T,E) division emp_p_e21(E).
/assert team_p_e21_n(T) :- team(T,E) division work(E,P,_) division work(e21,P,_).
emp_p_e21(E)
team_p_e21(T)
team_p_e21_n(T)
%
% Semi naive optimization
%
/abolish
/optimize_sn on
/display_answer off
/display_statistics on
/assert p(T,1)
/assert p(T,X):-p(T,Y),Y<T,X=Y+1
p(400,X)
p(400,X)
/abolish
/assert q(X):-X=1;q(Y),Y<500,X=Y+1
/assert p(X):-q(X)
/assert r(X):-p(X)
p(X)
p(X)
/c examples/family
ancestor(tom,X)
ancestor(tom,X)
/abolish
create or replace table t(a) as with r(a) as select 1 union all select a+1 from r where a<100 select * from r 
select top 10 * from t
select top 1000 * from t
/abolish
% /assert n(X):-X=1;n(Y),X=Y+1
% top(1,n(X))
% top(1,n(X))
% top(300,n(X))
% top(300,n(X))
% /abolish
% /assert n(X):-X=1
% /assert n(X):-n(X1),X1<1000,X=X1+1
% n(X)
% n(500)
% n(500),n(500)
% top(3,n(X))
% top(3,n(X))
% top(10,n(X))
% top(10,n(X))
/display_answer on
/optimize_sn off
/display_statistics off
/statistics off
/reset_statistics
% Detected and solved bugs
% False positive in make_safe_list (the binding X=Y was pushed away in the compilation)
v(X):-group_by((p(X),q(Y),X=Y),[Y],true).
% Type error was not shown
create or replace table t(a int, b int);
select concat(a,a) from t;
% Non-grouped attributes were allowed in Having:
select a from t group by a having b=1;
% Non-grouped attributes were allowed in expressions:
select count(*), a+1 from t
% Attribute t was not found
create or replace table t(a int);
create or replace table s(a int,b int);
create or replace table r(b int); 
select * from (t join s using (a)) join r using (b);
% Duplicated renaming
select t.a from t join (select x.a from s x join r y on x.b = y.b) z on t.a = z.a;
% False positive in inconsistent condition
create or replace table t(a float);
select a from t e1 where select e1.a> select avg(a) from t;
% Failed type inference in assumed group_by
with media(m) as (select avg(a) from t) select a from t, media where a>m;
% Failed because rand can take 0 or 1 arguments:
/ra project rand (dual)
% Inner function length was not unnested:
select substr('101',length('101')-1,1);
% The projection list was evaluated before the where condition
with v(a) as select 0 select 1/a from v where a>0;
% This raises an exception because of force_simplify_goals. Should it be avoided?
% Also note that SWI-Prolog returns a different information in the exception message
select 1/0 from dual where 1>2;
% Two issues: Correlation did not work and no tuple matched the condition
create or replace table t(a int);
create or replace table s(a int, b int);
insert into t values (1);
insert into s values (1,2);
update t as c set a=(select b from s where s.a=c.a) where a=1;
% Failed to correctly map arguments in natural inner join
create or replace table t(a int, b int);
create or replace table s(a int, b int);
create or replace view v as
SELECT a FROM t NATURAL JOIN (SELECT b, MAX(a) AS a FROM s GROUP BY b);
% Incorrect autocast simplification for 'or', which raised an exception
/type_casting on
create or replace table t(a string NOT NULL CHECK(a<=10 AND a>=1) );
insert into t values ('10');
% Unrecognized start of input (due to argument ordering)
create or replace table t(b int, a int);
create or replace table s(a int, c int);
t nfjoin s;
/type_casting off
/c examples/dldebugger/parity
br_is_even
/debug_datalog br_is_even
v
v
n
n
y
w
/c examples/dldebugger/orbits1
/debug_datalog planet(X) p
v
v
n
v
v
y
w
/debug_datalog planet(X) c
v
v
n
w
v
v
/c examples/dldebugger/example1.dl  
t(c,X)    
/debug_datalog p(F)
v
v
n
v
n
/debug_dl t/2 file(debug/dldebugger/example1.dl)
ma,c
/debug_dl p/1 file(debug/dldebugger/example1.dl)
w2
n
/debug_dl planet/1 file(debug/dldebugger/orbits1.dl)
mearth
y
y
w1
y
/c examples/dldebugger/orbits1
/tapi /debug_dl planet/1 missing(planet(earth))
/tapi /debug_dl_answer all(star/1) valid 
/tapi /debug_dl_answer all(orbits/2) valid 
/tapi /debug_dl_answer all(intermediate/2) wrong(intermediate(earth,sun))
/tapi /debug_dl_answer subset('_wintermediate11'/2,orbits/2) valid
/c examples/dldebugger/orbits1
/tapi /debug_dl planet/1 missing(planet(earth))
/tapi /debug_dl_answer all(star/1) valid 
/tapi /debug_dl_answer all(orbits/2) valid 
/tapi /debug_dl_set_node intermediate/2 wrong(intermediate(earth,sun))
/tapi /debug_dl_answer subset('_wintermediate11'/2,orbits/2) valid
/c examples/DLDebugger/parity
/tapi /debug_dl br_is_even/0
/tapi /debug_dl_answer all(between/2) valid 
/tapi /debug_dl_answer all(odd/1) wrong(odd(b))
/tapi /debug_dl_answer all(even/1) missing(even(b))
/tapi /debug_dl_answer subset('_wodd11'/1,even/1) valid
/tapi /debug_dl_answer subset('_wodd12'/2,next/2) nonvalid
/tapi /debug_dl_answer all(has_preceding/1) nonvalid 
/tapi /debug_dl_answer all(br/1) valid 
/c examples/DLDebugger/parity
/tapi /debug_dl br_is_even/0
/tapi /debug_dl_answer all(between/2) valid 
/tapi /debug_dl_set_node odd/1 wrong(odd(b))
/tapi /debug_dl_set_node even/1 missing(even(b))
/tapi /debug_dl_answer subset('_wodd11'/1,even/1) valid
/tapi /debug_dl_answer subset('_wodd12'/2,next/2) nonvalid
/tapi /debug_dl_answer all(has_preceding/1) nonvalid 
/tapi /debug_dl_answer all(br/1) valid 
% HOMEWORK 1: SQL

/abolish
/multiline on
/show_compilations on
/duplicates on
/order_answer off
CREATE TABLE Empleados (Nombre CHAR(50) NOT NULL, DNI CHAR(9) PRIMARY KEY, Sueldo NUMBER(6,2));
CREATE TABLE Teléfonos (DNI CHAR(9) REFERENCES Empleados, Teléfono CHAR(9), PRIMARY KEY (DNI, Teléfono));
CREATE TABLE "Códigos postales" ("Código postal" CHAR(5) PRIMARY KEY, Población CHAR(50) NOT NULL, Provincia CHAR(50) NOT NULL);
CREATE TABLE Domicilios (DNI CHAR(9) REFERENCES Empleados, Calle CHAR(50), "Código postal" CHAR(5) REFERENCES "Códigos postales", PRIMARY KEY (DNI, Calle, "Código postal"));
INSERT INTO Empleados VALUES('Antonio Arjona','12345678A',5000.0);
INSERT INTO Empleados VALUES('Carlota Cerezo','12345678C',1000.0);
INSERT INTO Empleados VALUES('Laura López','12345678L',1500.0);
INSERT INTO Empleados VALUES('Pedro Pérez','12345678P',2000.0);
INSERT INTO Teléfonos VALUES('12345678C','611111111');
INSERT INTO Teléfonos VALUES('12345678C','931111111');
INSERT INTO Teléfonos VALUES('12345678L','913333333');
INSERT INTO Teléfonos VALUES('12345678P','913333333');
INSERT INTO Teléfonos VALUES('12345678P','644444444');
INSERT INTO "Códigos postales" VALUES('08050','Parets','Barcelona');
INSERT INTO "Códigos postales" VALUES('14200','Peñarroya','Córdoba');
INSERT INTO "Códigos postales" VALUES('14900','Lucena','Córdoba');
INSERT INTO "Códigos postales" VALUES('28040','Madrid','Madrid');
INSERT INTO "Códigos postales" VALUES('50008','Zaragoza','Zaragoza');
INSERT INTO "Códigos postales" VALUES('28004','Arganda','Madrid');
INSERT INTO Domicilios VALUES('12345678A','Avda. Complutense','28040');
INSERT INTO Domicilios VALUES('12345678A','Cántaro','28004');
INSERT INTO Domicilios VALUES('12345678P','Diamante','14200');
INSERT INTO Domicilios VALUES('12345678P','Carbón','14900');
INSERT INTO Domicilios VALUES('12345678L','Diamante','14200');
-- 1) Listado de empleados que muestre Nombre, Calle y Código postal ordenados por Código postal y Nombre.
--	Primera solución: con la sintaxis estándar para las reuniones.
SELECT Nombre, Calle, "Código postal"
FROM Empleados NATURAL INNER JOIN Domicilios 
ORDER BY "Código postal", Nombre;
--	Segunda solución: con la sintaxis clásica de Oracle para las reuniones.
SELECT Nombre, Calle, "Código postal"
FROM Empleados, Domicilios
WHERE Empleados.DNI=Domicilios.DNI
ORDER BY "Código postal", Nombre;
-- 2) Listado de los empleados ordenados por nombre que muestre Nombre, DNI, Calle, Código postal, Teléfono de dos formas diferentes:
-- a) Sólo los empleados que tengan teléfono.
SELECT Nombre, DNI, Calle, "Código postal", Teléfono
FROM (Empleados NATURAL LEFT OUTER JOIN Domicilios) NATURAL INNER JOIN Teléfonos
ORDER BY Nombre;
-- b) Los empleados que tengan teléfono como los que no.
SELECT Nombre, DNI, Calle, "Código postal", Teléfono
FROM Empleados NATURAL LEFT OUTER JOIN (Teléfonos NATURAL LEFT OUTER JOIN Domicilios)
ORDER BY Nombre;
-- 3) Listado de los empleados que muestre Nombre, DNI, Calle, Población, Provincia y Código postal ordenados por nombre.
SELECT Nombre, DNI, Calle, Población, Provincia, "Código postal"
FROM Empleados NATURAL LEFT OUTER JOIN 
(Domicilios NATURAL INNER JOIN "Códigos postales")
ORDER BY Nombre;
-- 4) Listado de los empleados que muestre Nombre, DNI, Calle, Población, Provincia, Código postal y Teléfono ordenados por nombre.
SELECT Nombre, DNI, Calle, Población, Provincia, "Código postal", Teléfono
FROM (((Empleados NATURAL LEFT OUTER JOIN Teléfonos) NATURAL LEFT OUTER JOIN (Domicilios NATURAL INNER JOIN "Códigos postales")))
ORDER BY Nombre;
-- 5) Incrementar en un 10% el sueldo de todos los empleados, de forma que el sueldo aumentado no supere en ningún caso 1.900 .
UPDATE Empleados SET Sueldo = Sueldo*1.1 
WHERE Sueldo*1.1 <= 1900.0;
-- 8) Listado del número total de empleados, el sueldo máximo, el mínimo y el medio.
SELECT COUNT(*) AS "Número empleados", MIN(Sueldo) AS "Sueldo mínimo", MAX(Sueldo) AS "Sueldo máximo", AVG(Sueldo) AS "Sueldo medio"
FROM Empleados;
-- 9)	Listado de sueldo medio y número de empleados por población ordenado por población.
-- a) Contabilizar el empleado tantas veces como domicilios tenga.
SELECT  AVG(Sueldo) AS "Sueldo medio", Población 
FROM ((Empleados NATURAL LEFT OUTER JOIN Domicilios) NATURAL LEFT OUTER JOIN "Códigos postales")
GROUP BY Población
ORDER BY Población;
-- 10)	Listado de código postal, sueldo medio, mínimo y máximo por población y ordenado por sueldo medio descendentemente.
SELECT "Código postal", AVG(Sueldo), MIN(Sueldo), MAX(Sueldo) 
FROM Empleados NATURAL INNER JOIN Domicilios 
GROUP BY "Código postal" 
ORDER BY AVG(Sueldo) DESC;
% HOMEWORK 2: SQL
/abolish
create table programadores(dni string primary key, nombre string, dirección string, teléfono string);
insert into programadores values('1','Jacinto','Jazmín 4','91-8888888');
insert into programadores values('2','Herminia','Rosa 4','91-7777777');
insert into programadores values('3','Calixto','Clavel 3','91-1231231');
insert into programadores values('4','Teodora','Petunia 3','91-6666666');
create table analistas(dni string primary key, nombre string, dirección string, teléfono string);
insert into analistas values('4','Teodora','Petunia 3','91-6666666');
insert into analistas values('5','Evaristo','Luna 1','91-1111111');
insert into analistas values('6','Luciana','Júpiter 2','91-8888888');
insert into analistas values('7','Nicodemo','Plutón 3',NULL);
create table distribución(códigoPr string, dniEmp string, horas int, primary key (códigoPr, dniEmp));
insert into distribución values('P1','1',10);
insert into distribución values('P1','2',40);
insert into distribución values('P1','4',5);
insert into distribución values('P2','4',10);
insert into distribución values('P3','1',10);
insert into distribución values('P3','3',40);
insert into distribución values('P3','4',5);
insert into distribución values('P3','5',30);
insert into distribución values('P4','4',20);
insert into distribución values('P4','5',10);
create table proyectos(código string primary key, descripción string, dniDir string);
insert into proyectos values('P1','Nómina','4');
insert into proyectos values('P2','Contabilidad','4');
insert into proyectos values('P3','Producción','5');
insert into proyectos values('P4','Clientes','5');
insert into proyectos values('P5','Ventas','6');
-- Vista1: Unión de programadores y analistas
CREATE VIEW vista1 AS SELECT dni FROM programadores UNION SELECT dni FROM analistas;
-- Vista2: Empleados que son tanto programadores como analistas
CREATE VIEW vista2 AS SELECT dni FROM programadores INTERSECT SELECT dni FROM analistas;
-- Vista3: Todos menos los que están asignados a proyecto o son directores
CREATE VIEW vista3 AS SELECT dni FROM vista1 EXCEPT ((SELECT dniEmp FROM distribución) UNION (SELECT dniDir FROM proyectos));
-- Vista 4: Todos los proyectos menos en los que trabajen analistas
-- La siguiente no vale porque hay un empleado que es a la vez programador y analista
CREATE VIEW vista4 AS SELECT códigoPr FROM distribución,programadores WHERE dniEmp=dni;
CREATE OR REPLACE VIEW vista4 AS
 SELECT código 
 FROM proyectos 
 EXCEPT (SELECT códigoPr
         FROM distribución,analistas 
         WHERE dni=dniEmp);
-- Vista 5: Analistas que dirijan proyectos que no sean programadores
CREATE OR REPLACE VIEW vista5 AS
 SELECT DISTINCT dni 
 FROM analistas,proyectos
 WHERE dni=dniDir AND
       dni NOT IN (SELECT dni
                   FROM programadores);
-- Vista 6: Nombres de proyectos con programadores y horas
CREATE OR REPLACE VIEW vista6 AS
  SELECT descripción,nombre,horas
  FROM proyectos,distribución,programadores
  WHERE dniEmp=dni AND
        proyectos.código=distribución.códigoPr;
-- Vista 7: Teléfonos compartidos por empleados
CREATE OR REPLACE VIEW empleados AS
  SELECT * FROM programadores
  UNION
  SELECT * FROM analistas;
CREATE OR REPLACE VIEW vista7 AS
  SELECT teléfono
  FROM empleados
  GROUP BY teléfono
  HAVING COUNT(*)>1;
-- Vista 8: Empleados con mínima dedicación
   -- La versión actual de DES (3.0) no resuelve bien esta vista debido a un bug que ya está corregido para la próxima release
CREATE OR REPLACE VIEW vista8 AS
  SELECT dniEmp
  FROM distribución
  GROUP BY dniEmp
  HAVING SUM(horas) =  SELECT MIN(totalHoras)
                       FROM (SELECT SUM(horas) totalHoras 
                             FROM distribución 
                             GROUP BY dniEmp);
-- Vista 9: Distribución media de horas por cada proyecto
  -- Una primera solución (pero la media de los proyectos que no aparecen en distribución es null en lugar de 0):
CREATE OR REPLACE VIEW vista9 AS
  SELECT código,AVG(horas) AS mediaHoras
  FROM proyectos LEFT OUTER JOIN distribución ON código = códigoPr
  GROUP BY código;
  -- En la segunda ya aparecen los proyectos sin asignaciones con 0 horas
CREATE OR REPLACE VIEW vista9 AS
  SELECT códigoPr,AVG(horas) AS mediaHoras
  FROM distribución 
  GROUP BY códigoPr
  UNION 
  SELECT código,0.0 AS mediaHoras
  FROM proyectos
  WHERE código NOT IN (SELECT códigoPr FROM distribución)
  ;
-- Vista 10: Número total de horas asignadas a los proyectos dirigidos por 'Teodora'
CREATE OR REPLACE VIEW vista10 AS
SELECT SUM(horas)
FROM distribución,proyectos,empleados 
WHERE código = códigoPr 
  AND dniDir = dni 
  AND nombre = 'Teodora';
-- Vista 11: Media de horas de los empleados (analistas y programadores) asignados a proyectos tales que superen la media de horas.
CREATE OR REPLACE VIEW vista11 AS
SELECT * 
FROM vista9
WHERE mediaHoras > (SELECT AVG(mediaHoras)
                    FROM vista9);
-- Consultas sobre las vistas:
select * from vista1;
select * from vista2;
select * from vista3;
select * from vista4;
select * from vista5;
select * from vista6;
select * from vista7;
select * from vista8;
select * from vista9;
select * from vista10;
select * from vista11;
/order_answer on
% HOMEWORK 3: Extended RA
/abolish
/show_sql on

create table programadores(dni string primary key, nombre string, dirección string, teléfono string);
insert into programadores values('1','Jacinto','Jazmín 4','91-8888888');
insert into programadores values('2','Herminia','Rosa 4','91-7777777');
insert into programadores values('3','Calixto','Clavel 3','91-1231231');
insert into programadores values('4','Teodora','Petunia 3','91-6666666');

create table analistas(dni string primary key, nombre string, dirección string, teléfono string);
insert into analistas values('4','Teodora','Petunia 3','91-6666666');
insert into analistas values('5','Evaristo','Luna 1','91-1111111');
insert into analistas values('6','Luciana','Júpiter 2','91-8888888');
insert into analistas values('7','Nicodemo','Plutón 3',NULL);

create table distribución(códigopr string, dniemp string, horas int, primary key (códigopr, dniemp));
insert into distribución values('P1','1',10);
insert into distribución values('P1','2',40);
insert into distribución values('P1','4',5);
insert into distribución values('P2','4',10);
insert into distribución values('P3','1',10);
insert into distribución values('P3','3',40);
insert into distribución values('P3','4',5);
insert into distribución values('P3','5',30);
insert into distribución values('P4','4',20);
insert into distribución values('P4','5',10);

create table proyectos(código string primary key, descripción string, dnidir string);
insert into proyectos values('P1','Nómina','4');
insert into proyectos values('P2','Contabilidad','4');
insert into proyectos values('P3','Producción','5');
insert into proyectos values('P4','Clientes','5');
insert into proyectos values('P5','Ventas','6');

-- Vista1: Empleados que son programadores y analistas
vista1 := project dni (programadores njoin analistas);
-- Vista 2: Horas totales de cada empleado
vista2(dni, horas) :=  group_by [dniemp] dniemp,sum(horas) true (distribución);
-- Vista 3:
empleados := programadores union analistas;
vista3(dni, nombre, proyecto) := project dni,nombre,códigopr (empleados ljoin dni=dniemp distribución);
-- Vista 4:
vista4(dni, nombre) :=  project dni,nombre (select (teléfono is null) (empleados));
-- Vista 5: 
mediaHoras(media) := group_by [] avg(horas) true (rename p(horas) (group_by [códigopr] avg(horas) true (distribución)));
vista5(dni, número) := group_by dniemp,media dniemp,avg(horas) avg(horas)<avg(media) (distribución product mediaHoras);
-- Vista 6: Horas ampliadas en un 20%
proyectosEvaristo := project códigopr (empleados zjoin (dni=dniemp and nombre='Evaristo') distribución);
empleadosProyectosEvaristo := project dniemp (distribución njoin proyectosEvaristo);
empleadosNoEnProyectosEvaristo(dniemp) := project dni (empleados) difference empleadosProyectosEvaristo;
vista6(códigopr, dni, horas) := project códigopr,dniemp,horas*1.2 (distribución njoin empleadosNoEnProyectosEvaristo);
-- Vista 7: División
empleados   := programadores union analistas;
proyempl(códigopr,dniemp) := project códigopr,dniemp (distribución);
vista7(dni) := project dniemp (proyempl division proyectosEvaristo);
-- Vista 8: División
-- alfa=proyempl
-- beta=proyectosEvaristo
-- A=códigopr,dniemp
-- B=códigopr
-- A-B=dniemp
todos(dniemp) := distinct (project dniemp (proyempl)); -- Just if duplicates are enabled
menos(dniemp) := project dniemp ((proyectosEvaristo product todos) difference proyempl);
vista8(dni) := todos difference menos;
-- Vista 9: Recursión
jefeDirecto(dir,emp) := project dnidir,dniemp (proyectos zjoin código=códigopr distribución);
jefe(dir,emp) := 
  jefeDirecto
   union 
  (project jefeDirecto.dir,jefe.emp (jefeDirecto zjoin jefeDirecto.emp=jefe.dir jefe));
vista9(dni) := project emp (jefe zjoin dir=dni and nombre='Evaristo' empleados);

-- Consultas sobre las vistas:
select true (vista1);
select true (vista2);
select true (vista3);
select true (vista4);
select true (vista5);
select true (vista6);
select true (vista7);
select true (vista8);
select true (vista9);
/show_sql off
/multiline off
%/timing on
% Statistics numbers vary if duplicates are enabled/disabled
/compact_listings on
/verbose on
/display_statistics on
% Complete computations optimization
/optimize_cc  off
/optimize_ep  off
/optimize_nrp off
/optimize_st  off
%/assert p(X):-X=1
/assert p(1)
p(X)
p(X)
/clear_et
/optimize_cc  on
p(X)
p(X)
% Extensional predicate optimization
% /abolish
% /assert p(1)
/optimize_cc  off
/optimize_ep  on
/optimize_nrp off
/optimize_st  off
/clear_et
p(X)
p(X)
/optimize_cc on
p(X)
% Non-recursive predicate optimization
/abolish
/optimize_cc  off
/optimize_ep  off
/optimize_nrp off
/optimize_st  off
/assert p(1)
/assert p(X):-X=1+1
p(X)
/optimize_nrp on
/clear_et
p(X)
% Stratum optimization
/abolish
/optimize_cc  off
/optimize_ep  off
/optimize_nrp off
/optimize_st  off
/display_answer off
/display_nbr_of_tuples off
/timing on
:-type(p(a:int))
/assert p(1)
/assert p(X):-p(Y),X=Y+1,Y<5
select * from p
/optimize_st  on
select * from p
/optimize_cc  on
/optimize_ep  on
/optimize_nrp on
/optimize_st  off
/statistics off
/display_answer on
/display_nbr_of_tuples on
/timing off
/compact_listings on
%%%%%%%%%%%%%%
% Hypothetical queries
%%%%%%%%%%%%%%
/multiline off
/duplicates off
/abolish
a=>a
t(1)=>t(X)
t(1)/\t(2)=>t(X)
/assert b:-a
/assert r:-a=>b
r
/listing
/abolish
/assert path(1,2)
/assert path(2,3)
/assert path(3,4)
(path(X,Y):-path(X,Z),path(Z,Y)) => path(U,V)
% Variables in the consequent are not related to those in the antecedent
r(Y,X):-(path(X,Y):-path(X,Z),path(Z,Y)) => path(Y,X)
/abolish
/assert p(1,2)                                                 
/assert r(X,Y):-p(2,3)/\(p(U,V):-p(U,W),p(W,V))/\p(3,4)=>p(X,Y) 
r(X,Y)  
/abolish
/assert p:-a=>q
/assert q:-b=>c
/assert c:-b
p
/abolish
/assert b:-a
/assert b:-(a=>a)
b
/abolish
/duplicates on
a=>b=>c=>a,b,c
/assert a:-b
(b:-a)/\b=>a
(b:-a)/\a=>a
(b:-not(a))/\b=>a
a=>a;a
a=>(a;a)
a=>a;a
a=>(a;a)
t(1)/\t(1)=>t(X)
/duplicates off
/abolish
:-t(X),X<0
t(0)/\t(-1)=>t(X)
t(X)
t(-2)/\t(2)=>t(X)
t(X)
t(0)/\t(-1)/\t(1)=>t(X)
t(X)
/abolish
/assert p:-p=>p
p
/abolish
/assert p:-a=>(b:-a)=>b
p
/abolish
/assert p:-a=>(p:-a)=>p
p
a
/abolish               
/assert p:-a=>(p:-a)=>a
p
/abolish
/assert q:-a=>p
/assert p:-a=>q
p
q
/abolish           
/assert p:-a       
/assert p:-a=>p
p
/abolish
/assert p:-a=>p    
/assert p:-(q:-a)=>q
p
q
a
/abolish
/assert p:-(q:-a)=>q
/assert p:-a=>p    
p
% Negation
/abolish
p=>p
p=>not(p)
q=>not(p)
/abolish
/assert p :- (p:-not(q)) => p
p
/assert q
p
/abolish
/assert p:-q
/assert q:-(q:-not(p))=>p
p
/abolish
p=>(q:-not(p))=>(r:-not(q))=>r
p=>(q:-not(p))=>(r:-not(q))=>not(r)
p=>(q:-not(p))=>(r:-not(q))=>q
p=>(q:-not(p))=>(r:-not(q))=>not(q)
p=>(q:-not(p))=>(r:-not(q))=>p
p=>(q:-not(p))=>(r:-not(q))=>not(p)
/c debug/hypothetical/grad
grad(S)
take(tony,eng) => grad(tony) 
-take(pete,his) => grad(S)  
take(tony,eng) /\ take(adam,his) => grad(S)
(grad(S) :- take(S,his), take(S,lp)) => grad(S)
pre(lp,hist)=>pre(X,X)
:-pre(X,X)
pre(lp,hist)=>pre(X,Y)
/abolish
/assert p(X) :- X=1 ; p(Y), Y<10, X=Y+1
(-p(X) :- p(X), X mod 2 = 1) => p(X)
/c examples/hypothetical/coins
heads /\ tails => win 
/c examples/hypothetical/nim  
/duplicates on
win_nim
/duplicates off
/abolish
/assert r :- b => p.
/assert p :- not(b).
r
p
r
/abolish
/assert r :- p,(b => p),p.
/assert p :- not(b).
r
p
r
/abolish
/assert p:-a=>q
/assert q:-b=>p
/assert p:-b,a
p
q
/c examples/hypothetical/flight
flight_travel(X,Y)
flight_travel(X,Y),(closed(b)=>flight_travel(X,Y))
flight_travel(X,Y),(closed(b)=>not(flight_travel(X,Y)))  
/abolish
/hypothetical off
drop table if exists l;
with l as select 1 select * from l;
with l(a) as select 1 select * from l;
with l(a) as select 1, l as select 2 select * from l;
with l(a) as select 1, l(a) as select 2 select * from l;
assume select 1 in l select * from l;
assume select 1 in l(a) select * from l;
assume select 1 in l(a), select 2 in l select * from l;
assume select 1 in l(a), select 2 in l(a) select * from l;
assume select 1 in l(a), select 1 not in l(a), select 1 in l(a) select * from l;
create table l(a int);
insert into l values (3);
with l as select 1 select * from l;
with l(a) as select 1 select * from l;
with l(a) as select 1, l as select 2 select * from l;
with l(a) as select 1, l(a) as select 2 select * from l;
assume select 1 in l select * from l;
assume select 1 in l(a) select * from l;
assume select 1 in l(a), select 2 in l select * from l;
assume select 1 in l(a), select 2 in l(a) select * from l;
assume select 1 in l(a), select 1 not in l(a), select 1 in l(a) select * from l;
/hypothetical on
drop table l;
with l as select 1 select * from l;
with l(a) as select 1 select * from l;
with l(a) as select 1, l as select 2 select * from l;
with l(a) as select 1, l(a) as select 2 select * from l;
assume select 1 in l select * from l;
assume select 1 in l(a) select * from l;
assume select 1 in l(a), select 2 in l select * from l;
assume select 1 in l(a), select 2 in l(a) select * from l;
assume select 1 in l(a), select 1 not in l(a), select 1 in l(a) select * from l;
create table l(a int);
insert into l values (3);
with l as select 1 select * from l;
with l(a) as select 1 select * from l;
with l(a) as select 1, l as select 2 select * from l;
with l(a) as select 1, l(a) as select 2 select * from l;
assume select 1 in l select * from l;
assume select 1 in l(a) select * from l;
assume select 1 in l(a), select 2 in l select * from l;
assume select 1 in l(a), select 2 in l(a) select * from l;
assume select 1 in l(a), select 1 not in l(a), select 1 in l(a) select * from l;
/abolish
/multiline on
CREATE TABLE flight(origin string, destination string, time real);
INSERT INTO flight VALUES('lon','ny',9.0);
INSERT INTO flight VALUES('mad','par',1.5);
INSERT INTO flight VALUES('par','ny',10.0);
CREATE OR REPLACE VIEW travel(origin,destination,time) AS 
  WITH connected(origin,destination,time) AS 
      SELECT * FROM flight 
    UNION 
      SELECT flight.origin,connected.destination,
             flight.time+connected.time 
      FROM flight,connected 
      WHERE flight.destination = connected.origin 
  SELECT * FROM connected;
SELECT * FROM travel;
ASSUME
    SELECT 'mad','lon',2.0
  IN
    flight(origin,destination,time)
SELECT * FROM travel;
CREATE VIEW connect(origin,destination) AS
  SELECT origin,destination FROM flight;
SELECT * FROM connect;
ASSUME 
    (SELECT flight.origin,connect.destination
     FROM flight,connect
     WHERE flight.destination = connect.origin) 
  IN 
    connect(origin,destination) 
SELECT * FROM connect;
WITH 
  connect(origin,destination) AS 
      (SELECT flight.origin,connect.destination 
       FROM flight,connect 
       WHERE flight.destination = connect.origin) 
SELECT * FROM connect;
WITH
  flight(origin,destination,time) AS
    SELECT 'mad','lon',2.0 
    UNION
    SELECT 'par','ber',3.0
SELECT * FROM travel;
ASSUME 
    SELECT 'mad','lon',2.0 
    UNION
    SELECT 'par','ber',3.0
  IN 
    flight(origin,destination,time) 
SELECT * FROM travel;
WITH
  flight AS
    SELECT 'mad','lon',2.0,
  flight AS
    SELECT 'par','ber',3.0
SELECT * FROM travel;
ASSUME 
    SELECT 'mad','lon',2.0 
  IN flight,
    SELECT 'par','ber',3.0
  IN flight
SELECT * FROM travel;
create or replace view p(a) as assume select 1 in p(a) select * from p;
select * from p;
/p examples/hypothetical/canary
/abolish
/multiline off
%
% MODES
%
/abolish
/verbose on
/assert p(2,2)
/list_modes
/retract p(2,2)
/list_modes
/assert p(1,X)
/list_modes
/assert p(2,2)
/list_modes
/retract p(2,2)
/list_modes
/assert p(X,3)
/list_modes
/retract p(1,X)
/list_modes
/retract p(X,3)
/list_modes
/assert p(2,2)
/list_modes
/retract p(2,2)
%
% TYPE CASTING
%
/abolish
/multiline off
/type_casting off
/duplicates on
create or replace table t(a int, b float, c varchar(3))
select 1
select 1+1
select 1+1.0
select round(1.0)
select round(1)
select float(1)
select float(1.0)
select a from select 1 a
select a+1 from select 1 a
select a+1.0 from select 1 a
select a+1 from select 1.0 a
insert into t(a) values (1)
insert into t(a) values (1.0)
insert into t(a) select 1/3
insert into t(a) values ('1')
insert into t(a) values ('1.0')
insert into t(a) values ('1.0E1')
insert into t(a) values ('a')
insert into t(b) values (1)
insert into t(b) values (1.0)
insert into t(b) select 1/3
insert into t(b) values ('1')
insert into t(b) values ('1.0')
insert into t(b) values ('1.0E1')
insert into t(b) values ('a')
insert into t(c) values (1)
insert into t(c) values (1.0)
insert into t(c) values ('1')
insert into t(c) values ('1.0')
insert into t(c) values ('a')
insert into t(c) select 1/3
/type_casting on
select 1
select 1+1
select 1+1.0
select round(1.0)
select round(1)
select float(1)
select float(1.0)
select a from select 1 a
select a+1 from select 1 a
select a+1.0 from select 1 a
select a+1 from select 1.0 a
insert into t(a) values (1)
insert into t(a) values (1.0)
insert into t(a) select 1/3
insert into t(a) values ('1')
insert into t(a) values ('1.0')
insert into t(a) values ('1.0E1')
insert into t(a) values ('a')
insert into t(b) values (1)
insert into t(b) values (1.0)
insert into t(b) select 1/3
insert into t(b) values ('1')
insert into t(b) values ('1.0')
insert into t(b) values ('1.0E1')
insert into t(b) values ('a')
insert into t(c) values (1)
insert into t(c) values (1.0)
insert into t(c) values ('1')
insert into t(c) values ('1.0')
insert into t(c) values ('a')
insert into t(c) select 1/3
drop table t
:-type(t(a:int,b:float,c:string,d:varchar(2)))
/assert t(1.5,1,2,123)
/listing
/assert t('4','5.0E10','','') 
/listing                     
:-type(p(a:int))    
/assert p('foo')        
/retract t(1.5,1,2,123)      
/assert p(X) :- X='1'
/type_casting off
drop table t
create table t(a int primary key, b string, check (a>0))
insert into t values(1,'a')
alter table t alter column a string default ''
/type_casting on
alter table t alter column a string default ''
select * from t
/type_casting off
/duplicates off
/show_compilations on
/set_flag dbms standard
/p debug/des_autocast
/type_casting on
/p debug/des_autocast
/if $debug_mode$=basic /goto basic
/type_casting off
/set_flag dbms access
/open_db access
/p debug/des_autocast
/set_flag dbms standard
/open_db db2
/p debug/des_autocast
/open_db mysql
/p debug/des_autocast
/open_db postgresql
/p debug/des_autocast
/set_flag dbms sqlserver
/open_db sqlserver
/p debug/des_autocast
/use_ddb
/type_casting on
:basic
/close_dbs
/abolish
/sql
create table t(a int);
select a from t+;
/parse select a from t+;
/tapi /parse select a from t+;
create table s(a int);
select 1 from t,s;
/parse select 1 from t,s;
/tapi /parse select 1 from t,s;
create table traca(a int);
select * from taca;
/parse select * from taca;
/tapi /parse select * from taca;
select * from x;
/parse select * from x;
/tapi /parse select * from x;
/tapi /mparse
SELECT *
FROM Club
WHER Num_socios > 10;
$eot
selet 1
/parse selet 1
/tapi /parse selet 1
/datalog
/cd
/cd debug
/order_answer on
/system_mode fuzzy
/development on
/verbose on
/p des_fuzzy_1
/c kundu
/development off
/verbose off
/p des_fuzzy_1
/c kundu
/verbose on
/stop_stopwatch
/host_statistics runtime
% Finish logging
/nolog
% Quit
/q
