1) Identificador de user pueden ser palabras reservadas pero excepto UNION EXCEPT INTERSECT y MINUS, 
porque si son identificador esta sentencia "select * from a union select * from b"; 
lo trata como 2 select, "select * from a union" y "select * from b", 
lo he intentando solucionarlo intercambiando statements poniendo
statements UNION, MINUS... antes de statement select_DQL 
pero en este caso el programa es menos eficiente y  en el caso de 
"select iif(count(*)>0,'ok','error') from select * from t minus select * from s" lo trata como 
"select iif(count(*)>0,'ok','error') from select * from t "  MINUS  "select * from s" (except(...))
y lo correcto sera que el MINUS esta dentro del from 
"...from([(except(distinct,(select(all,top(all),no_offset,*,[],from([(t,_)]),..."
No se si tienes algún consejo para solucionar esto.

2)tmlStmt([savepoint([SP])|STs]/STs) -->
  [cmd(savepoint):_],
  filename(FileName)                  # 'double quotes id (savepoint name)',
  {atom_concat(FileName,'.ddb',SP)}.
Veo que fileName no solo puden ser double quotes id que tambien podria ser hasta numeros, str y palabras reservadas...
Quiero saber que podrian ser filename, veo en des_commands que puede ser cualquier entre double quotes
o que no incluyan ninguno de los que caracteres ";" pero no estoy seguro.

3) 
my_sql_left_quotation_mark("[",ACCESS) :-
  to_uppercase(ACCESS,'ACCESS'),
  !. 
my_sql_left_quotation_mark("",DB2) :-
  to_uppercase(DB2,'DB2'),
  !.
my_sql_left_quotation_mark("`",MYSQL) :-
  to_uppercase(MYSQL,'MYSQL'),
  !.
...... 
......
No se para que sirven estos predicados.
se que es una parte de las reglas para reconocer los identificadores encerrado por "[", """" y "`" 
pero no se la utilidad de los predicados mencionado arriba y no se si hace falta implementarlo.

4)Los Joins son bastantes ineficientes si pongo mas de 4 sentencias de Joins en un mismo fichero.sql tardan bastante tiempo en parsear, 
no estoy seguro de que si en el sistema DES de ahora también es asi, ya que no se como podré ver el tiempo de ejecucion.

5)Para la sentencia "select * from t1 division t2"
DES actual sale:  
(...from([(('t1',_)division('t2',_),_)])...)
En el que hice yo sale:
(...from([(division((t1,_),(t2,_)),_)])...)
No es problema de version de SWI-prolog ya que en 7.6 y 8.4 sale igual.
(version 8.4.3 solo se podia la depuracion grafica
y solo la segunda vez que ejecuta la misma sentencia como se puede ver en division2.png).
Y en division.png podemos ver que todos sale igual excepto
la unificacion ultima JR = division(LR,RR) que no se porque sale distinto
la unica diferencia entre los dos casos es que en DES es 't1', 't2' y en otro es t1, t2 sin comillas.

-------------------------------------------------------------------------------------
Las cosas que faltan que ya estan implementado en el sistema actual de DES (para no olvidarse)

-El gestion de error, habrá que hacer modificaciones. 
-syntax_check_redef, syntax_check_same_types...
-Gestion de los constantes relacionados con tiempo(DATE, TIME, DATETIME Y TIMESTAMP)
 (Ya tengo implementado uno simplificado para ver los resultados que sale y hacer comparacion
 habra que sustituir por los que estan en DES).
-allowed_with_schemas
-create_or_replace_view()
